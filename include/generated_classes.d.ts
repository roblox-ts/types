// THIS FILE IS GENERATED AUTOMATICALLY AND SHOULD NOT BE EDITED BY HAND!

/// <reference no-default-lib="true"/>
/// <reference path="roblox.d.ts" />
/// <reference path="manual.d.ts" />
/// <reference path="generated_enums.d.ts" />

// CREATABLE INSTANCES INTERNAL TABLE

interface CreatableInstancesInternal {
	Accessory: Accessory;
	Hat: Hat;
	AdvancedDragger: AdvancedDragger;
	Animation: Animation;
	AnimationController: AnimationController;
	Animator: Animator;
	Attachment: Attachment;
	Backpack: Backpack;
	HopperBin: HopperBin;
	Flag: Flag;
	Beam: Beam;
	BindableEvent: BindableEvent;
	BindableFunction: BindableFunction;
	BodyAngularVelocity: BodyAngularVelocity;
	BodyForce: BodyForce;
	BodyGyro: BodyGyro;
	BodyPosition: BodyPosition;
	BodyThrust: BodyThrust;
	BodyVelocity: BodyVelocity;
	RocketPropulsion: RocketPropulsion;
	Camera: Camera;
	BodyColors: BodyColors;
	CharacterMesh: CharacterMesh;
	Pants: Pants;
	Shirt: Shirt;
	ShirtGraphic: ShirtGraphic;
	Skin: Skin;
	ClickDetector: ClickDetector;
	Configuration: Configuration;
	AlignOrientation: AlignOrientation;
	AlignPosition: AlignPosition;
	BallSocketConstraint: BallSocketConstraint;
	HingeConstraint: HingeConstraint;
	LineForce: LineForce;
	RodConstraint: RodConstraint;
	RopeConstraint: RopeConstraint;
	CylindricalConstraint: CylindricalConstraint;
	PrismaticConstraint: PrismaticConstraint;
	SpringConstraint: SpringConstraint;
	Torque: Torque;
	VectorForce: VectorForce;
	HumanoidController: HumanoidController;
	SkateboardController: SkateboardController;
	VehicleController: VehicleController;
	CustomEvent: CustomEvent;
	CustomEventReceiver: CustomEventReceiver;
	BlockMesh: BlockMesh;
	CylinderMesh: CylinderMesh;
	SpecialMesh: SpecialMesh;
	DebuggerWatch: DebuggerWatch;
	Dialog: Dialog;
	DialogChoice: DialogChoice;
	Dragger: Dragger;
	Explosion: Explosion;
	Texture: Texture;
	Hole: Hole;
	MotorFeature: MotorFeature;
	Fire: Fire;
	Folder: Folder;
	ForceField: ForceField;
	FunctionalTest: FunctionalTest;
	Frame: Frame;
	ImageButton: ImageButton;
	TextButton: TextButton;
	ImageLabel: ImageLabel;
	TextLabel: TextLabel;
	ScrollingFrame: ScrollingFrame;
	TextBox: TextBox;
	ViewportFrame: ViewportFrame;
	BillboardGui: BillboardGui;
	GuiMain: GuiMain;
	SurfaceGui: SurfaceGui;
	FloorWire: FloorWire;
	BoxHandleAdornment: BoxHandleAdornment;
	ConeHandleAdornment: ConeHandleAdornment;
	CylinderHandleAdornment: CylinderHandleAdornment;
	ImageHandleAdornment: ImageHandleAdornment;
	LineHandleAdornment: LineHandleAdornment;
	SphereHandleAdornment: SphereHandleAdornment;
	SelectionBox: SelectionBox;
	SelectionSphere: SelectionSphere;
	ArcHandles: ArcHandles;
	Handles: Handles;
	SurfaceSelection: SurfaceSelection;
	SelectionPartLasso: SelectionPartLasso;
	SelectionPointLasso: SelectionPointLasso;
	Humanoid: Humanoid;
	HumanoidDescription: HumanoidDescription;
	RotateP: RotateP;
	RotateV: RotateV;
	Glue: Glue;
	ManualGlue: ManualGlue;
	ManualWeld: ManualWeld;
	Motor6D: Motor6D;
	Rotate: Rotate;
	Snap: Snap;
	VelocityMotor: VelocityMotor;
	Weld: Weld;
	Keyframe: Keyframe;
	KeyframeMarker: KeyframeMarker;
	KeyframeSequence: KeyframeSequence;
	PointLight: PointLight;
	SpotLight: SpotLight;
	SurfaceLight: SurfaceLight;
	LocalizationTable: LocalizationTable;
	LocalScript: LocalScript;
	ModuleScript: ModuleScript;
	Hint: Hint;
	CornerWedgePart: CornerWedgePart;
	FlagStand: FlagStand;
	Seat: Seat;
	SkateboardPlatform: SkateboardPlatform;
	SpawnLocation: SpawnLocation;
	WedgePart: WedgePart;
	MeshPart: MeshPart;
	NegateOperation: NegateOperation;
	UnionOperation: UnionOperation;
	TrussPart: TrussPart;
	VehicleSeat: VehicleSeat;
	PartOperationAsset: PartOperationAsset;
	ParticleEmitter: ParticleEmitter;
	PluginAction: PluginAction;
	Pose: Pose;
	BloomEffect: BloomEffect;
	BlurEffect: BlurEffect;
	ColorCorrectionEffect: ColorCorrectionEffect;
	SunRaysEffect: SunRaysEffect;
	ReflectionMetadata: ReflectionMetadata;
	ReflectionMetadataCallbacks: ReflectionMetadataCallbacks;
	ReflectionMetadataClasses: ReflectionMetadataClasses;
	ReflectionMetadataEnums: ReflectionMetadataEnums;
	ReflectionMetadataEvents: ReflectionMetadataEvents;
	ReflectionMetadataFunctions: ReflectionMetadataFunctions;
	ReflectionMetadataClass: ReflectionMetadataClass;
	ReflectionMetadataEnum: ReflectionMetadataEnum;
	ReflectionMetadataEnumItem: ReflectionMetadataEnumItem;
	ReflectionMetadataMember: ReflectionMetadataMember;
	ReflectionMetadataProperties: ReflectionMetadataProperties;
	ReflectionMetadataYieldFunctions: ReflectionMetadataYieldFunctions;
	RemoteEvent: RemoteEvent;
	RemoteFunction: RemoteFunction;
	RenderingTest: RenderingTest;
	Sky: Sky;
	Smoke: Smoke;
	Sound: Sound;
	ChorusSoundEffect: ChorusSoundEffect;
	CompressorSoundEffect: CompressorSoundEffect;
	DistortionSoundEffect: DistortionSoundEffect;
	EchoSoundEffect: EchoSoundEffect;
	EqualizerSoundEffect: EqualizerSoundEffect;
	FlangeSoundEffect: FlangeSoundEffect;
	PitchShiftSoundEffect: PitchShiftSoundEffect;
	ReverbSoundEffect: ReverbSoundEffect;
	TremoloSoundEffect: TremoloSoundEffect;
	SoundGroup: SoundGroup;
	Sparkles: Sparkles;
	StarterGear: StarterGear;
	StarterCharacterScripts: StarterCharacterScripts;
	Team: Team;
	TerrainRegion: TerrainRegion;
	Trail: Trail;
	Tween: Tween;
	UIAspectRatioConstraint: UIAspectRatioConstraint;
	UISizeConstraint: UISizeConstraint;
	UITextSizeConstraint: UITextSizeConstraint;
	UIGridLayout: UIGridLayout;
	UIListLayout: UIListLayout;
	UIPageLayout: UIPageLayout;
	UITableLayout: UITableLayout;
	UIPadding: UIPadding;
	UIScale: UIScale;
	BinaryStringValue: BinaryStringValue;
	BoolValue: BoolValue;
	BrickColorValue: BrickColorValue;
	CFrameValue: CFrameValue;
	Color3Value: Color3Value;
	DoubleConstrainedValue: DoubleConstrainedValue;
	IntConstrainedValue: IntConstrainedValue;
	IntValue: IntValue;
	NumberValue: NumberValue;
	ObjectValue: ObjectValue;
	RayValue: RayValue;
	StringValue: StringValue;
	Vector3Value: Vector3Value;
	WeldConstraint: WeldConstraint;
}

// INSTANCES INTERNAL TABLE

interface InstancesInternal extends CreatableInstancesInternal {
	Instance: Instance;
	ABTestService: ABTestService;
	AdService: AdService;
	AnalyticsService: AnalyticsService;
	AnimationTrack: AnimationTrack;
	AssetService: AssetService;
	BackpackItem: BackpackItem;
	BadgeService: BadgeService;
	BasePlayerGui: BasePlayerGui;
	CoreGui: CoreGui;
	PlayerGui: PlayerGui;
	StarterGui: StarterGui;
	BodyMover: BodyMover;
	BrowserService: BrowserService;
	CacheableContentProvider: CacheableContentProvider;
	MeshContentProvider: MeshContentProvider;
	SolidModelContentProvider: SolidModelContentProvider;
	ChangeHistoryService: ChangeHistoryService;
	CharacterAppearance: CharacterAppearance;
	Clothing: Clothing;
	Chat: Chat;
	ClusterPacketCache: ClusterPacketCache;
	CollectionService: CollectionService;
	Constraint: Constraint;
	SlidingBallConstraint: SlidingBallConstraint;
	ContentProvider: ContentProvider;
	ContextActionService: ContextActionService;
	Controller: Controller;
	ControllerService: ControllerService;
	CookiesService: CookiesService;
	CorePackages: CorePackages;
	CoreScriptSyncService: CoreScriptSyncService;
	DataModelMesh: DataModelMesh;
	BevelMesh: BevelMesh;
	DataStoreService: DataStoreService;
	Debris: Debris;
	DebugSettings: DebugSettings;
	DebuggerBreakpoint: DebuggerBreakpoint;
	DebuggerManager: DebuggerManager;
	FaceInstance: FaceInstance;
	Feature: Feature;
	File: File;
	FlagStandService: FlagStandService;
	FlyweightService: FlyweightService;
	CSGDictionaryService: CSGDictionaryService;
	NonReplicatedCSGDictionaryService: NonReplicatedCSGDictionaryService;
	FriendService: FriendService;
	GamePassService: GamePassService;
	GameSettings: GameSettings;
	GamepadService: GamepadService;
	Geometry: Geometry;
	GlobalDataStore: GlobalDataStore;
	OrderedDataStore: OrderedDataStore;
	GoogleAnalyticsConfiguration: GoogleAnalyticsConfiguration;
	GroupService: GroupService;
	GuiBase: GuiBase;
	GuiBase2d: GuiBase2d;
	GuiObject: GuiObject;
	GuiButton: GuiButton;
	GuiLabel: GuiLabel;
	LayerCollector: LayerCollector;
	PluginGui: PluginGui;
	DockWidgetPluginGui: DockWidgetPluginGui;
	QWidgetPluginGui: QWidgetPluginGui;
	GuiBase3d: GuiBase3d;
	PVAdornment: PVAdornment;
	HandleAdornment: HandleAdornment;
	ParabolaAdornment: ParabolaAdornment;
	PartAdornment: PartAdornment;
	HandlesBase: HandlesBase;
	SelectionLasso: SelectionLasso;
	GuiService: GuiService;
	GuidRegistryService: GuidRegistryService;
	HapticService: HapticService;
	Hopper: Hopper;
	HttpRbxApiService: HttpRbxApiService;
	HttpRequest: HttpRequest;
	HttpService: HttpService;
	InputObject: InputObject;
	InsertService: InsertService;
	JointInstance: JointInstance;
	DynamicRotate: DynamicRotate;
	ManualSurfaceJointInstance: ManualSurfaceJointInstance;
	JointsService: JointsService;
	KeyboardService: KeyboardService;
	KeyframeSequenceProvider: KeyframeSequenceProvider;
	Light: Light;
	Lighting: Lighting;
	LocalStorageService: LocalStorageService;
	AppStorageService: AppStorageService;
	UserStorageService: UserStorageService;
	LocalizationService: LocalizationService;
	LogService: LogService;
	LoginService: LoginService;
	LuaSettings: LuaSettings;
	LuaSourceContainer: LuaSourceContainer;
	BaseScript: BaseScript;
	CoreScript: CoreScript;
	LuaWebService: LuaWebService;
	MarketplaceService: MarketplaceService;
	MessagingService: MessagingService;
	Mouse: Mouse;
	PlayerMouse: PlayerMouse;
	PluginMouse: PluginMouse;
	MouseService: MouseService;
	NetworkMarker: NetworkMarker;
	NetworkPeer: NetworkPeer;
	NetworkClient: NetworkClient;
	NetworkServer: NetworkServer;
	NetworkReplicator: NetworkReplicator;
	ClientReplicator: ClientReplicator;
	ServerReplicator: ServerReplicator;
	NetworkSettings: NetworkSettings;
	NotificationService: NotificationService;
	PVInstance: PVInstance;
	BasePart: BasePart;
	FormFactorPart: FormFactorPart;
	Platform: Platform;
	Terrain: Terrain;
	Status: Status;
	Workspace: Workspace;
	PackageLink: PackageLink;
	Pages: Pages;
	DataStorePages: DataStorePages;
	FriendPages: FriendPages;
	InventoryPages: InventoryPages;
	StandardPages: StandardPages;
	Path: Path;
	PathfindingService: PathfindingService;
	PhysicsPacketCache: PhysicsPacketCache;
	PhysicsService: PhysicsService;
	PhysicsSettings: PhysicsSettings;
	Player: Player;
	PlayerScripts: PlayerScripts;
	Players: Players;
	Plugin: Plugin;
	PluginDragEvent: PluginDragEvent;
	PluginGuiService: PluginGuiService;
	PluginManager: PluginManager;
	PluginMenu: PluginMenu;
	PluginToolbar: PluginToolbar;
	PluginToolbarButton: PluginToolbarButton;
	PointsService: PointsService;
	PostEffect: PostEffect;
	ReflectionMetadataItem: ReflectionMetadataItem;
	RenderSettings: RenderSettings;
	ReplicatedFirst: ReplicatedFirst;
	ReplicatedStorage: ReplicatedStorage;
	RobloxReplicatedStorage: RobloxReplicatedStorage;
	RunService: RunService;
	RuntimeScriptService: RuntimeScriptService;
	ScriptContext: ScriptContext;
	ScriptDebugger: ScriptDebugger;
	ScriptService: ScriptService;
	Selection: Selection;
	ServerScriptService: ServerScriptService;
	ServerStorage: ServerStorage;
	ServiceProvider: ServiceProvider;
	DataModel: DataModel;
	GenericSettings: GenericSettings;
	AnalysticsSettings: AnalysticsSettings;
	GlobalSettings: GlobalSettings;
	UserSettings: UserSettings;
	SocialService: SocialService;
	SoundEffect: SoundEffect;
	SoundService: SoundService;
	SpawnerService: SpawnerService;
	StarterPack: StarterPack;
	StarterPlayer: StarterPlayer;
	Stats: Stats;
	StatsItem: StatsItem;
	RunningAverageItemDouble: RunningAverageItemDouble;
	RunningAverageItemInt: RunningAverageItemInt;
	RunningAverageTimeIntervalItem: RunningAverageTimeIntervalItem;
	TotalCountTimeIntervalItem: TotalCountTimeIntervalItem;
	StopWatchReporter: StopWatchReporter;
	Studio: Studio;
	StudioService: StudioService;
	StudioTheme: StudioTheme;
	TaskScheduler: TaskScheduler;
	Teams: Teams;
	TeleportService: TeleportService;
	TestService: TestService;
	TextFilterResult: TextFilterResult;
	TextService: TextService;
	ThirdPartyUserService: ThirdPartyUserService;
	TimerService: TimerService;
	TouchInputService: TouchInputService;
	TouchTransmitter: TouchTransmitter;
	Translator: Translator;
	TweenBase: TweenBase;
	TweenService: TweenService;
	UIBase: UIBase;
	UIComponent: UIComponent;
	UIConstraint: UIConstraint;
	UILayout: UILayout;
	UIGridStyleLayout: UIGridStyleLayout;
	UserGameSettings: UserGameSettings;
	UserInputService: UserInputService;
	VRService: VRService;
	ValueBase: ValueBase;
	VirtualInputManager: VirtualInputManager;
	VirtualUser: VirtualUser;
	Visit: Visit;
}

// INSTANCE BASES TABLE

interface InstanceBases extends InstancesInternal {
	Accoutrement: DerivesFromAccoutrement;
	Tool: DerivesFromTool;
	FileMesh: DerivesFromFileMesh;
	Decal: DerivesFromDecal;
	ScreenGui: DerivesFromScreenGui;
	Motor: DerivesFromMotor;
	Script: DerivesFromScript;
	Message: DerivesFromMessage;
	Part: DerivesFromPart;
	PartOperation: DerivesFromPartOperation;
	Model: DerivesFromModel;
	StarterPlayerScripts: DerivesFromStarterPlayerScripts;
}

// CREATABLE INSTANCES TABLE

interface CreatableInstances extends CreatableInstancesInternal {
	Accoutrement: Accoutrement;
	Tool: Tool;
	FileMesh: FileMesh;
	Decal: Decal;
	ScreenGui: ScreenGui;
	Motor: Motor;
	Script: Script;
	Message: Message;
	Part: Part;
	PartOperation: PartOperation;
	Model: Model;
	StarterPlayerScripts: StarterPlayerScripts;
}

// INSTANCES TABLE

interface Instances extends InstancesInternal, CreatableInstances {
}

// BASE TYPES TABLE

interface BaseTypes {
	Instance: RbxInstance;
	ABTestService: RbxABTestService;
	Accoutrement: RbxAccoutrement;
	Accessory: RbxAccessory;
	Hat: RbxHat;
	AdService: RbxAdService;
	AdvancedDragger: RbxAdvancedDragger;
	AnalyticsService: RbxAnalyticsService;
	Animation: RbxAnimation;
	AnimationController: RbxAnimationController;
	AnimationTrack: RbxAnimationTrack;
	Animator: RbxAnimator;
	AssetService: RbxAssetService;
	Attachment: RbxAttachment;
	Backpack: RbxBackpack;
	BackpackItem: RbxBackpackItem;
	HopperBin: RbxHopperBin;
	Tool: RbxTool;
	Flag: RbxFlag;
	BadgeService: RbxBadgeService;
	BasePlayerGui: RbxBasePlayerGui;
	CoreGui: RbxCoreGui;
	PlayerGui: RbxPlayerGui;
	StarterGui: RbxStarterGui;
	Beam: RbxBeam;
	BindableEvent: RbxBindableEvent;
	BindableFunction: RbxBindableFunction;
	BodyMover: RbxBodyMover;
	BodyAngularVelocity: RbxBodyAngularVelocity;
	BodyForce: RbxBodyForce;
	BodyGyro: RbxBodyGyro;
	BodyPosition: RbxBodyPosition;
	BodyThrust: RbxBodyThrust;
	BodyVelocity: RbxBodyVelocity;
	RocketPropulsion: RbxRocketPropulsion;
	BrowserService: RbxBrowserService;
	CacheableContentProvider: RbxCacheableContentProvider;
	MeshContentProvider: RbxMeshContentProvider;
	SolidModelContentProvider: RbxSolidModelContentProvider;
	Camera: RbxCamera;
	ChangeHistoryService: RbxChangeHistoryService;
	CharacterAppearance: RbxCharacterAppearance;
	BodyColors: RbxBodyColors;
	CharacterMesh: RbxCharacterMesh;
	Clothing: RbxClothing;
	Pants: RbxPants;
	Shirt: RbxShirt;
	ShirtGraphic: RbxShirtGraphic;
	Skin: RbxSkin;
	Chat: RbxChat;
	ClickDetector: RbxClickDetector;
	ClusterPacketCache: RbxClusterPacketCache;
	CollectionService: RbxCollectionService;
	Configuration: RbxConfiguration;
	Constraint: RbxConstraint;
	AlignOrientation: RbxAlignOrientation;
	AlignPosition: RbxAlignPosition;
	BallSocketConstraint: RbxBallSocketConstraint;
	HingeConstraint: RbxHingeConstraint;
	LineForce: RbxLineForce;
	RodConstraint: RbxRodConstraint;
	RopeConstraint: RbxRopeConstraint;
	SlidingBallConstraint: RbxSlidingBallConstraint;
	CylindricalConstraint: RbxCylindricalConstraint;
	PrismaticConstraint: RbxPrismaticConstraint;
	SpringConstraint: RbxSpringConstraint;
	Torque: RbxTorque;
	VectorForce: RbxVectorForce;
	ContentProvider: RbxContentProvider;
	ContextActionService: RbxContextActionService;
	Controller: RbxController;
	HumanoidController: RbxHumanoidController;
	SkateboardController: RbxSkateboardController;
	VehicleController: RbxVehicleController;
	ControllerService: RbxControllerService;
	CookiesService: RbxCookiesService;
	CorePackages: RbxCorePackages;
	CoreScriptSyncService: RbxCoreScriptSyncService;
	CustomEvent: RbxCustomEvent;
	CustomEventReceiver: RbxCustomEventReceiver;
	DataModelMesh: RbxDataModelMesh;
	BevelMesh: RbxBevelMesh;
	BlockMesh: RbxBlockMesh;
	CylinderMesh: RbxCylinderMesh;
	FileMesh: RbxFileMesh;
	SpecialMesh: RbxSpecialMesh;
	DataStoreService: RbxDataStoreService;
	Debris: RbxDebris;
	DebugSettings: RbxDebugSettings;
	DebuggerBreakpoint: RbxDebuggerBreakpoint;
	DebuggerManager: RbxDebuggerManager;
	DebuggerWatch: RbxDebuggerWatch;
	Dialog: RbxDialog;
	DialogChoice: RbxDialogChoice;
	Dragger: RbxDragger;
	Explosion: RbxExplosion;
	FaceInstance: RbxFaceInstance;
	Decal: RbxDecal;
	Texture: RbxTexture;
	Feature: RbxFeature;
	Hole: RbxHole;
	MotorFeature: RbxMotorFeature;
	File: RbxFile;
	Fire: RbxFire;
	FlagStandService: RbxFlagStandService;
	FlyweightService: RbxFlyweightService;
	CSGDictionaryService: RbxCSGDictionaryService;
	NonReplicatedCSGDictionaryService: RbxNonReplicatedCSGDictionaryService;
	Folder: RbxFolder;
	ForceField: RbxForceField;
	FriendService: RbxFriendService;
	FunctionalTest: RbxFunctionalTest;
	GamePassService: RbxGamePassService;
	GameSettings: RbxGameSettings;
	GamepadService: RbxGamepadService;
	Geometry: RbxGeometry;
	GlobalDataStore: RbxGlobalDataStore;
	OrderedDataStore: RbxOrderedDataStore;
	GoogleAnalyticsConfiguration: RbxGoogleAnalyticsConfiguration;
	GroupService: RbxGroupService;
	GuiBase: RbxGuiBase;
	GuiBase2d: RbxGuiBase2d;
	GuiObject: RbxGuiObject;
	Frame: RbxFrame;
	GuiButton: RbxGuiButton;
	ImageButton: RbxImageButton;
	TextButton: RbxTextButton;
	GuiLabel: RbxGuiLabel;
	ImageLabel: RbxImageLabel;
	TextLabel: RbxTextLabel;
	ScrollingFrame: RbxScrollingFrame;
	TextBox: RbxTextBox;
	ViewportFrame: RbxViewportFrame;
	LayerCollector: RbxLayerCollector;
	BillboardGui: RbxBillboardGui;
	PluginGui: RbxPluginGui;
	DockWidgetPluginGui: RbxDockWidgetPluginGui;
	QWidgetPluginGui: RbxQWidgetPluginGui;
	ScreenGui: RbxScreenGui;
	GuiMain: RbxGuiMain;
	SurfaceGui: RbxSurfaceGui;
	GuiBase3d: RbxGuiBase3d;
	FloorWire: RbxFloorWire;
	PVAdornment: RbxPVAdornment;
	HandleAdornment: RbxHandleAdornment;
	BoxHandleAdornment: RbxBoxHandleAdornment;
	ConeHandleAdornment: RbxConeHandleAdornment;
	CylinderHandleAdornment: RbxCylinderHandleAdornment;
	ImageHandleAdornment: RbxImageHandleAdornment;
	LineHandleAdornment: RbxLineHandleAdornment;
	SphereHandleAdornment: RbxSphereHandleAdornment;
	ParabolaAdornment: RbxParabolaAdornment;
	SelectionBox: RbxSelectionBox;
	SelectionSphere: RbxSelectionSphere;
	PartAdornment: RbxPartAdornment;
	HandlesBase: RbxHandlesBase;
	ArcHandles: RbxArcHandles;
	Handles: RbxHandles;
	SurfaceSelection: RbxSurfaceSelection;
	SelectionLasso: RbxSelectionLasso;
	SelectionPartLasso: RbxSelectionPartLasso;
	SelectionPointLasso: RbxSelectionPointLasso;
	GuiService: RbxGuiService;
	GuidRegistryService: RbxGuidRegistryService;
	HapticService: RbxHapticService;
	Hopper: RbxHopper;
	HttpRbxApiService: RbxHttpRbxApiService;
	HttpRequest: RbxHttpRequest;
	HttpService: RbxHttpService;
	Humanoid: RbxHumanoid;
	HumanoidDescription: RbxHumanoidDescription;
	InputObject: RbxInputObject;
	InsertService: RbxInsertService;
	JointInstance: RbxJointInstance;
	DynamicRotate: RbxDynamicRotate;
	RotateP: RbxRotateP;
	RotateV: RbxRotateV;
	Glue: RbxGlue;
	ManualSurfaceJointInstance: RbxManualSurfaceJointInstance;
	ManualGlue: RbxManualGlue;
	ManualWeld: RbxManualWeld;
	Motor: RbxMotor;
	Motor6D: RbxMotor6D;
	Rotate: RbxRotate;
	Snap: RbxSnap;
	VelocityMotor: RbxVelocityMotor;
	Weld: RbxWeld;
	JointsService: RbxJointsService;
	KeyboardService: RbxKeyboardService;
	Keyframe: RbxKeyframe;
	KeyframeMarker: RbxKeyframeMarker;
	KeyframeSequence: RbxKeyframeSequence;
	KeyframeSequenceProvider: RbxKeyframeSequenceProvider;
	Light: RbxLight;
	PointLight: RbxPointLight;
	SpotLight: RbxSpotLight;
	SurfaceLight: RbxSurfaceLight;
	Lighting: RbxLighting;
	LocalStorageService: RbxLocalStorageService;
	AppStorageService: RbxAppStorageService;
	UserStorageService: RbxUserStorageService;
	LocalizationService: RbxLocalizationService;
	LocalizationTable: RbxLocalizationTable;
	LogService: RbxLogService;
	LoginService: RbxLoginService;
	LuaSettings: RbxLuaSettings;
	LuaSourceContainer: RbxLuaSourceContainer;
	BaseScript: RbxBaseScript;
	CoreScript: RbxCoreScript;
	Script: RbxScript;
	LocalScript: RbxLocalScript;
	ModuleScript: RbxModuleScript;
	LuaWebService: RbxLuaWebService;
	MarketplaceService: RbxMarketplaceService;
	Message: RbxMessage;
	Hint: RbxHint;
	MessagingService: RbxMessagingService;
	Mouse: RbxMouse;
	PlayerMouse: RbxPlayerMouse;
	PluginMouse: RbxPluginMouse;
	MouseService: RbxMouseService;
	NetworkMarker: RbxNetworkMarker;
	NetworkPeer: RbxNetworkPeer;
	NetworkClient: RbxNetworkClient;
	NetworkServer: RbxNetworkServer;
	NetworkReplicator: RbxNetworkReplicator;
	ClientReplicator: RbxClientReplicator;
	ServerReplicator: RbxServerReplicator;
	NetworkSettings: RbxNetworkSettings;
	NotificationService: RbxNotificationService;
	PVInstance: RbxPVInstance;
	BasePart: RbxBasePart;
	CornerWedgePart: RbxCornerWedgePart;
	FormFactorPart: RbxFormFactorPart;
	Part: RbxPart;
	FlagStand: RbxFlagStand;
	Platform: RbxPlatform;
	Seat: RbxSeat;
	SkateboardPlatform: RbxSkateboardPlatform;
	SpawnLocation: RbxSpawnLocation;
	WedgePart: RbxWedgePart;
	MeshPart: RbxMeshPart;
	PartOperation: RbxPartOperation;
	NegateOperation: RbxNegateOperation;
	UnionOperation: RbxUnionOperation;
	Terrain: RbxTerrain;
	TrussPart: RbxTrussPart;
	VehicleSeat: RbxVehicleSeat;
	Model: RbxModel;
	Status: RbxStatus;
	Workspace: RbxWorkspace;
	PackageLink: RbxPackageLink;
	Pages: RbxPages;
	DataStorePages: RbxDataStorePages;
	FriendPages: RbxFriendPages;
	InventoryPages: RbxInventoryPages;
	StandardPages: RbxStandardPages;
	PartOperationAsset: RbxPartOperationAsset;
	ParticleEmitter: RbxParticleEmitter;
	Path: RbxPath;
	PathfindingService: RbxPathfindingService;
	PhysicsPacketCache: RbxPhysicsPacketCache;
	PhysicsService: RbxPhysicsService;
	PhysicsSettings: RbxPhysicsSettings;
	Player: RbxPlayer;
	PlayerScripts: RbxPlayerScripts;
	Players: RbxPlayers;
	Plugin: RbxPlugin;
	PluginAction: RbxPluginAction;
	PluginDragEvent: RbxPluginDragEvent;
	PluginGuiService: RbxPluginGuiService;
	PluginManager: RbxPluginManager;
	PluginMenu: RbxPluginMenu;
	PluginToolbar: RbxPluginToolbar;
	PluginToolbarButton: RbxPluginToolbarButton;
	PointsService: RbxPointsService;
	Pose: RbxPose;
	PostEffect: RbxPostEffect;
	BloomEffect: RbxBloomEffect;
	BlurEffect: RbxBlurEffect;
	ColorCorrectionEffect: RbxColorCorrectionEffect;
	SunRaysEffect: RbxSunRaysEffect;
	ReflectionMetadata: RbxReflectionMetadata;
	ReflectionMetadataCallbacks: RbxReflectionMetadataCallbacks;
	ReflectionMetadataClasses: RbxReflectionMetadataClasses;
	ReflectionMetadataEnums: RbxReflectionMetadataEnums;
	ReflectionMetadataEvents: RbxReflectionMetadataEvents;
	ReflectionMetadataFunctions: RbxReflectionMetadataFunctions;
	ReflectionMetadataItem: RbxReflectionMetadataItem;
	ReflectionMetadataClass: RbxReflectionMetadataClass;
	ReflectionMetadataEnum: RbxReflectionMetadataEnum;
	ReflectionMetadataEnumItem: RbxReflectionMetadataEnumItem;
	ReflectionMetadataMember: RbxReflectionMetadataMember;
	ReflectionMetadataProperties: RbxReflectionMetadataProperties;
	ReflectionMetadataYieldFunctions: RbxReflectionMetadataYieldFunctions;
	RemoteEvent: RbxRemoteEvent;
	RemoteFunction: RbxRemoteFunction;
	RenderSettings: RbxRenderSettings;
	RenderingTest: RbxRenderingTest;
	ReplicatedFirst: RbxReplicatedFirst;
	ReplicatedStorage: RbxReplicatedStorage;
	RobloxReplicatedStorage: RbxRobloxReplicatedStorage;
	RunService: RbxRunService;
	RuntimeScriptService: RbxRuntimeScriptService;
	ScriptContext: RbxScriptContext;
	ScriptDebugger: RbxScriptDebugger;
	ScriptService: RbxScriptService;
	Selection: RbxSelection;
	ServerScriptService: RbxServerScriptService;
	ServerStorage: RbxServerStorage;
	ServiceProvider: RbxServiceProvider;
	DataModel: RbxDataModel;
	GenericSettings: RbxGenericSettings;
	AnalysticsSettings: RbxAnalysticsSettings;
	GlobalSettings: RbxGlobalSettings;
	UserSettings: RbxUserSettings;
	Sky: RbxSky;
	Smoke: RbxSmoke;
	SocialService: RbxSocialService;
	Sound: RbxSound;
	SoundEffect: RbxSoundEffect;
	ChorusSoundEffect: RbxChorusSoundEffect;
	CompressorSoundEffect: RbxCompressorSoundEffect;
	DistortionSoundEffect: RbxDistortionSoundEffect;
	EchoSoundEffect: RbxEchoSoundEffect;
	EqualizerSoundEffect: RbxEqualizerSoundEffect;
	FlangeSoundEffect: RbxFlangeSoundEffect;
	PitchShiftSoundEffect: RbxPitchShiftSoundEffect;
	ReverbSoundEffect: RbxReverbSoundEffect;
	TremoloSoundEffect: RbxTremoloSoundEffect;
	SoundGroup: RbxSoundGroup;
	SoundService: RbxSoundService;
	Sparkles: RbxSparkles;
	SpawnerService: RbxSpawnerService;
	StarterGear: RbxStarterGear;
	StarterPack: RbxStarterPack;
	StarterPlayer: RbxStarterPlayer;
	StarterPlayerScripts: RbxStarterPlayerScripts;
	StarterCharacterScripts: RbxStarterCharacterScripts;
	Stats: RbxStats;
	StatsItem: RbxStatsItem;
	RunningAverageItemDouble: RbxRunningAverageItemDouble;
	RunningAverageItemInt: RbxRunningAverageItemInt;
	RunningAverageTimeIntervalItem: RbxRunningAverageTimeIntervalItem;
	TotalCountTimeIntervalItem: RbxTotalCountTimeIntervalItem;
	StopWatchReporter: RbxStopWatchReporter;
	Studio: RbxStudio;
	StudioService: RbxStudioService;
	StudioTheme: RbxStudioTheme;
	TaskScheduler: RbxTaskScheduler;
	Team: RbxTeam;
	Teams: RbxTeams;
	TeleportService: RbxTeleportService;
	TerrainRegion: RbxTerrainRegion;
	TestService: RbxTestService;
	TextFilterResult: RbxTextFilterResult;
	TextService: RbxTextService;
	ThirdPartyUserService: RbxThirdPartyUserService;
	TimerService: RbxTimerService;
	TouchInputService: RbxTouchInputService;
	TouchTransmitter: RbxTouchTransmitter;
	Trail: RbxTrail;
	Translator: RbxTranslator;
	TweenBase: RbxTweenBase;
	Tween: RbxTween;
	TweenService: RbxTweenService;
	UIBase: RbxUIBase;
	UIComponent: RbxUIComponent;
	UIConstraint: RbxUIConstraint;
	UIAspectRatioConstraint: RbxUIAspectRatioConstraint;
	UISizeConstraint: RbxUISizeConstraint;
	UITextSizeConstraint: RbxUITextSizeConstraint;
	UILayout: RbxUILayout;
	UIGridStyleLayout: RbxUIGridStyleLayout;
	UIGridLayout: RbxUIGridLayout;
	UIListLayout: RbxUIListLayout;
	UIPageLayout: RbxUIPageLayout;
	UITableLayout: RbxUITableLayout;
	UIPadding: RbxUIPadding;
	UIScale: RbxUIScale;
	UserGameSettings: RbxUserGameSettings;
	UserInputService: RbxUserInputService;
	VRService: RbxVRService;
	ValueBase: RbxValueBase;
	BinaryStringValue: RbxBinaryStringValue;
	BoolValue: RbxBoolValue;
	BrickColorValue: RbxBrickColorValue;
	CFrameValue: RbxCFrameValue;
	Color3Value: RbxColor3Value;
	DoubleConstrainedValue: RbxDoubleConstrainedValue;
	IntConstrainedValue: RbxIntConstrainedValue;
	IntValue: RbxIntValue;
	NumberValue: RbxNumberValue;
	ObjectValue: RbxObjectValue;
	RayValue: RbxRayValue;
	StringValue: RbxStringValue;
	Vector3Value: RbxVector3Value;
	VirtualInputManager: RbxVirtualInputManager;
	VirtualUser: RbxVirtualUser;
	Visit: RbxVisit;
	WeldConstraint: RbxWeldConstraint;
}

// GENERATED ROBLOX INSTANCE CLASSES

// Instance
interface RbxInstance {
	/** Determines whether or not an Instance can be saved when the game closes/attempts to save the game. Note: this only applies to games that use Data Persistence, or SavePlaceAsync. */
	Archivable: boolean;
	Name: string;
	/** The Instance that is directly above this Instance in the tree. */
	Parent?: Instance;
	/** Removes all children (but not this object) from the workspace. */
	ClearAllChildren(): void;
	/** Removes object and all of its children from the workspace. Disconnects object and all children from open connections. Object and children may not be usable after calling Destroy. */
	Destroy(): void;
	/** Returns a string that shows the path from the root node (DataModel) to this Instance.  This string does not include the root node (DataModel). */
	GetFullName(): string;
	GetPropertyChangedSignal(property: string): RBXScriptSignal;
	IsAncestorOf(descendant: Instance): boolean;
	IsDescendantOf(ancestor: Instance): boolean;
	/** Fired when any of this object's ancestors change.  First argument 'child' is the object whose parent changed.  Second argument 'parent' is the first argument's new parent. */
	readonly AncestryChanged: RBXScriptSignal<(child: Instance, parent: Instance) => void>;
	/** Fired after a property changes value.  The property argument is the name of the property */
	readonly Changed: RBXScriptSignal<(property: string) => void>;
	readonly ChildAdded: RBXScriptSignal<(child: Instance) => void>;
	readonly ChildRemoved: RBXScriptSignal<(child: Instance) => void>;
	/** Fired after an Instance is parented to this object, or any of this object's descendants.  The 'descendant' argument is the Instance that is being added. */
	readonly DescendantAdded: RBXScriptSignal<(descendant: Instance) => void>;
	/** Fired after an Instance is unparented from this object, or any of this object's descendants.  The 'descendant' argument is the Instance that is being added. */
	readonly DescendantRemoving: RBXScriptSignal<(descendant: Instance) => void>;
}
type Instance = ABTestService | DerivesFromAccoutrement | AdService | AdvancedDragger | AnalyticsService | Animation | AnimationController | AnimationTrack | Animator | AssetService | Attachment | Backpack | BackpackItem | BadgeService | BasePlayerGui | Beam | BindableEvent | BindableFunction | BodyMover | BrowserService | CacheableContentProvider | Camera | ChangeHistoryService | CharacterAppearance | Chat | ClickDetector | ClusterPacketCache | CollectionService | Configuration | Constraint | ContentProvider | ContextActionService | Controller | ControllerService | CookiesService | CorePackages | CoreScriptSyncService | CustomEvent | CustomEventReceiver | DataModelMesh | DataStoreService | Debris | DebugSettings | DebuggerBreakpoint | DebuggerManager | DebuggerWatch | Dialog | DialogChoice | Dragger | Explosion | FaceInstance | Feature | File | Fire | FlagStandService | FlyweightService | Folder | ForceField | FriendService | FunctionalTest | GamePassService | GameSettings | GamepadService | Geometry | GlobalDataStore | GoogleAnalyticsConfiguration | GroupService | GuiBase | GuiService | GuidRegistryService | HapticService | Hopper | HttpRbxApiService | HttpRequest | HttpService | Humanoid | HumanoidDescription | InputObject | InsertService | JointInstance | JointsService | KeyboardService | Keyframe | KeyframeMarker | KeyframeSequence | KeyframeSequenceProvider | Light | Lighting | LocalStorageService | LocalizationService | LocalizationTable | LogService | LoginService | LuaSettings | LuaSourceContainer | LuaWebService | MarketplaceService | DerivesFromMessage | MessagingService | Mouse | MouseService | NetworkMarker | NetworkPeer | NetworkReplicator | NetworkSettings | NotificationService | PVInstance | PackageLink | Pages | PartOperationAsset | ParticleEmitter | Path | PathfindingService | PhysicsPacketCache | PhysicsService | PhysicsSettings | Player | PlayerScripts | Players | Plugin | PluginAction | PluginDragEvent | PluginGuiService | PluginManager | PluginMenu | PluginToolbar | PluginToolbarButton | PointsService | Pose | PostEffect | ReflectionMetadata | ReflectionMetadataCallbacks | ReflectionMetadataClasses | ReflectionMetadataEnums | ReflectionMetadataEvents | ReflectionMetadataFunctions | ReflectionMetadataItem | ReflectionMetadataProperties | ReflectionMetadataYieldFunctions | RemoteEvent | RemoteFunction | RenderSettings | RenderingTest | ReplicatedFirst | ReplicatedStorage | RobloxReplicatedStorage | RunService | RuntimeScriptService | ScriptContext | ScriptDebugger | ScriptService | Selection | ServerScriptService | ServerStorage | ServiceProvider | Sky | Smoke | SocialService | Sound | SoundEffect | SoundGroup | SoundService | Sparkles | SpawnerService | StarterGear | StarterPack | StarterPlayer | DerivesFromStarterPlayerScripts | Stats | StatsItem | StopWatchReporter | Studio | StudioService | StudioTheme | TaskScheduler | Team | Teams | TeleportService | TerrainRegion | TestService | TextFilterResult | TextService | ThirdPartyUserService | TimerService | TouchInputService | TouchTransmitter | Trail | Translator | TweenBase | TweenService | UIBase | UserGameSettings | UserInputService | VRService | ValueBase | VirtualInputManager | VirtualUser | Visit | WeldConstraint;

// ABTestService
interface RbxABTestService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ABTestService";
}
type ABTestService = RbxABTestService & Indexable<RbxABTestService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "ABTestService"): ABTestService;
}

// DerivesFromAccoutrement
interface RbxDerivesFromAccoutrement extends RbxInstance {
	AttachmentForward: Vector3;
	AttachmentPoint: CFrame;
	AttachmentPos: Vector3;
	AttachmentRight: Vector3;
	AttachmentUp: Vector3;
}
interface RbxAccoutrement extends RbxDerivesFromAccoutrement {
	readonly ClassName: "Accoutrement";
}

type Accoutrement = RbxAccoutrement & Indexable<RbxAccoutrement>;
type DerivesFromAccoutrement = Accoutrement | Accessory | Hat;

// Accessory
interface RbxAccessory extends RbxDerivesFromAccoutrement {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Accessory";
}
type Accessory = RbxAccessory & Indexable<RbxAccessory>;

// Hat
interface RbxHat extends RbxDerivesFromAccoutrement {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Hat";
}
type Hat = RbxHat & Indexable<RbxHat>;

// AdService
interface RbxAdService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "AdService";
}
type AdService = RbxAdService & Indexable<RbxAdService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "AdService"): AdService;
}

// AdvancedDragger
interface RbxAdvancedDragger extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "AdvancedDragger";
}
type AdvancedDragger = RbxAdvancedDragger & Indexable<RbxAdvancedDragger>;

// AnalyticsService
interface RbxAnalyticsService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "AnalyticsService";
}
type AnalyticsService = RbxAnalyticsService & Indexable<RbxAnalyticsService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "AnalyticsService"): AnalyticsService;
}

// Animation
interface RbxAnimation extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Animation";
	AnimationId: string;
}
type Animation = RbxAnimation & Indexable<RbxAnimation>;

// AnimationController
interface RbxAnimationController extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "AnimationController";
}
type AnimationController = RbxAnimationController & Indexable<RbxAnimationController>;

// AnimationTrack
interface RbxAnimationTrack extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "AnimationTrack";
	readonly Animation?: Animation;
	readonly IsPlaying: boolean;
	readonly Length: number;
	Looped: boolean;
	Priority: Enum.AnimationPriority;
	readonly Speed: number;
	TimePosition: number;
	readonly WeightCurrent: number;
	readonly WeightTarget: number;
	AdjustSpeed(speed?: number): void;
	AdjustWeight(weight?: number, fadeTime?: number): void;
	GetMarkerReachedSignal(name: string): RBXScriptSignal;
	GetTimeOfKeyframe(keyframeName: string): number;
	Play(fadeTime?: number, weight?: number, speed?: number): void;
	Stop(fadeTime?: number): void;
	readonly DidLoop: RBXScriptSignal<() => void>;
	readonly KeyframeReached: RBXScriptSignal<(keyframeName: string) => void>;
	readonly Stopped: RBXScriptSignal<() => void>;
}
type AnimationTrack = RbxAnimationTrack & Indexable<RbxAnimationTrack>;

// Animator
interface RbxAnimator extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Animator";
}
type Animator = RbxAnimator & Indexable<RbxAnimator>;

// AssetService
interface RbxAssetService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "AssetService";
	CreatePlaceAsync(placeName: string, templatePlaceID: number, description?: string): number;
	GetBundleDetailsAsync(bundleId: number): object;
	SavePlaceAsync(): void;
}
type AssetService = RbxAssetService & Indexable<RbxAssetService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "AssetService"): AssetService;
}

// Attachment
interface RbxAttachment extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Attachment";
	/** Primary axis. Corresponds to the LookVector, or the first column in the part-local Attachment CFrame rotation matrix */
	Axis: Vector3;
	CFrame: CFrame;
	/** Euler angles applied in YXZ order */
	Orientation: Vector3;
	Position: Vector3;
	/** Secondary axis. Corresponds to the UpVector, or the second column in the part-local Attachment CFrame rotation matrix */
	SecondaryAxis: Vector3;
	Visible: boolean;
	/** Primary axis in world space. Corresponds to the LookVector, or the first column in the world space Attachment CFrame rotation matrix. */
	WorldAxis: Vector3;
	WorldCFrame: CFrame;
	/** Euler angles applied in YXZ order */
	WorldOrientation: Vector3;
	WorldPosition: Vector3;
	WorldSecondaryAxis: Vector3;
}
type Attachment = RbxAttachment & Indexable<RbxAttachment>;

// Backpack
interface RbxBackpack extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Backpack";
}
type Backpack = RbxBackpack & Indexable<RbxBackpack>;

// BackpackItem
interface RbxBackpackItem extends RbxInstance {
	TextureId: string;
}
type BackpackItem = HopperBin | DerivesFromTool;

// HopperBin
interface RbxHopperBin extends RbxBackpackItem {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "HopperBin";
	Active: boolean;
	BinType: Enum.BinType;
	readonly Deselected: RBXScriptSignal<() => void>;
	readonly Selected: RBXScriptSignal<(mouse: Instance) => void>;
}
type HopperBin = RbxHopperBin & Indexable<RbxHopperBin>;

// DerivesFromTool
interface RbxDerivesFromTool extends RbxBackpackItem {
	CanBeDropped: boolean;
	Enabled: boolean;
	Grip: CFrame;
	GripForward: Vector3;
	GripPos: Vector3;
	GripRight: Vector3;
	GripUp: Vector3;
	ManualActivationOnly: boolean;
	RequiresHandle: boolean;
	ToolTip: string;
	Activate(): void;
	Deactivate(): void;
	readonly Activated: RBXScriptSignal<() => void>;
	readonly Deactivated: RBXScriptSignal<() => void>;
	readonly Equipped: RBXScriptSignal<(mouse: Instance) => void>;
	readonly Unequipped: RBXScriptSignal<() => void>;
}
interface RbxTool extends RbxDerivesFromTool {
	readonly ClassName: "Tool";
}

type Tool = RbxTool & Indexable<RbxTool>;
type DerivesFromTool = Tool | Flag;

// Flag
interface RbxFlag extends RbxDerivesFromTool {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Flag";
	/** The Team this flag is for. Corresponds with the TeamColors in the Teams service. */
	TeamColor: BrickColor;
}
type Flag = RbxFlag & Indexable<RbxFlag>;

// BadgeService
interface RbxBadgeService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "BadgeService";
	AwardBadge(userId: number, badgeId: number): boolean;
	GetBadgeInfoAsync(badgeId: number): object;
	UserHasBadgeAsync(userId: number, badgeId: number): boolean;
}
type BadgeService = RbxBadgeService & Indexable<RbxBadgeService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "BadgeService"): BadgeService;
}

// BasePlayerGui
interface RbxBasePlayerGui extends RbxInstance {
	GetGuiObjectsAtPosition(x: number, y: number): Array<Instance>;
}
type BasePlayerGui = CoreGui | PlayerGui | StarterGui;

// CoreGui
interface RbxCoreGui extends RbxBasePlayerGui {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "CoreGui";
	readonly Version: number;
}
type CoreGui = RbxCoreGui & Indexable<RbxCoreGui>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "CoreGui"): CoreGui;
}

// PlayerGui
interface RbxPlayerGui extends RbxBasePlayerGui {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "PlayerGui";
	readonly CurrentScreenOrientation: Enum.ScreenOrientation;
	ScreenOrientation: Enum.ScreenOrientation;
	/** Overrides the default selection adornment (used for gamepads). For best results, this should point to a GuiObject. */
	SelectionImageObject?: GuiObject;
	GetTopbarTransparency(): number;
	SetTopbarTransparency(transparency: number): void;
	readonly TopbarTransparencyChangedSignal: RBXScriptSignal<(transparency: number) => void>;
}
type PlayerGui = RbxPlayerGui & Indexable<RbxPlayerGui>;

// StarterGui
interface RbxStarterGui extends RbxBasePlayerGui {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "StarterGui";
	ScreenOrientation: Enum.ScreenOrientation;
	ShowDevelopmentGui: boolean;
	/** Returns a boolean describing whether a CoreGuiType is currently being rendered. */
	GetCoreGuiEnabled(coreGuiType: Enum.CoreGuiType): boolean;
	/** Will stop/begin certain core gui elements being rendered. See CoreGuiType for core guis that can be modified. */
	SetCoreGuiEnabled(coreGuiType: Enum.CoreGuiType, enabled: boolean): void;
}
type StarterGui = RbxStarterGui & Indexable<RbxStarterGui>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "StarterGui"): StarterGui;
}

// Beam
interface RbxBeam extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Beam";
	Attachment0?: Attachment;
	Attachment1?: Attachment;
	Color: ColorSequence;
	CurveSize0: number;
	CurveSize1: number;
	Enabled: boolean;
	FaceCamera: boolean;
	LightEmission: number;
	LightInfluence: number;
	Segments: number;
	Texture: string;
	TextureLength: number;
	TextureMode: Enum.TextureMode;
	TextureSpeed: number;
	Transparency: NumberSequence;
	Width0: number;
	Width1: number;
	ZOffset: number;
	SetTextureOffset(offset?: number): void;
}
type Beam = RbxBeam & Indexable<RbxBeam>;

// BindableEvent
interface RbxBindableEvent extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "BindableEvent";
}
type BindableEvent = RbxBindableEvent & Indexable<RbxBindableEvent>;

// BindableFunction
interface RbxBindableFunction extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "BindableFunction";
}
type BindableFunction = RbxBindableFunction & Indexable<RbxBindableFunction>;

// BodyMover
interface RbxBodyMover extends RbxInstance {
}
type BodyMover = BodyAngularVelocity | BodyForce | BodyGyro | BodyPosition | BodyThrust | BodyVelocity | RocketPropulsion;

// BodyAngularVelocity
interface RbxBodyAngularVelocity extends RbxBodyMover {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "BodyAngularVelocity";
	AngularVelocity: Vector3;
	MaxTorque: Vector3;
	P: number;
}
type BodyAngularVelocity = RbxBodyAngularVelocity & Indexable<RbxBodyAngularVelocity>;

// BodyForce
interface RbxBodyForce extends RbxBodyMover {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "BodyForce";
	Force: Vector3;
}
type BodyForce = RbxBodyForce & Indexable<RbxBodyForce>;

// BodyGyro
interface RbxBodyGyro extends RbxBodyMover {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "BodyGyro";
	/** The cframe that this force is trying to orient its parent Part to.  Note: this force only uses the rotation of the cframe, not the position. */
	CFrame: CFrame;
	/** The dampening factor applied to this force */
	D: number;
	/** The maximum torque that will be exerted on the Part */
	MaxTorque: Vector3;
	/** The power continually applied to this force */
	P: number;
}
type BodyGyro = RbxBodyGyro & Indexable<RbxBodyGyro>;

// BodyPosition
interface RbxBodyPosition extends RbxBodyMover {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "BodyPosition";
	/** The dampening factor applied to this force */
	D: number;
	/** The maximum force that will be exerted on the Part */
	MaxForce: Vector3;
	/** The power factor continually applied to this force */
	P: number;
	/** The Vector3 that this force is trying to position its parent Part to. */
	Position: Vector3;
	GetLastForce(): Vector3;
	readonly ReachedTarget: RBXScriptSignal<() => void>;
}
type BodyPosition = RbxBodyPosition & Indexable<RbxBodyPosition>;

// BodyThrust
interface RbxBodyThrust extends RbxBodyMover {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "BodyThrust";
	/** The power continually applied to this force */
	Force: Vector3;
	/** The Vector3 location of where to apply the force to.  */
	Location: Vector3;
}
type BodyThrust = RbxBodyThrust & Indexable<RbxBodyThrust>;

// BodyVelocity
interface RbxBodyVelocity extends RbxBodyMover {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "BodyVelocity";
	/** The maximum force that will be exerted on the Part in each axis */
	MaxForce: Vector3;
	/** The amount of power we add to the system.  The higher the power, the quicker the force will achieve its goal. */
	P: number;
	/** The velocity this system tries to achieve.  How quickly the system reaches this velocity (if ever) is defined by P. */
	Velocity: Vector3;
	GetLastForce(): Vector3;
	lastForce(): Vector3;
}
type BodyVelocity = RbxBodyVelocity & Indexable<RbxBodyVelocity>;

// RocketPropulsion
interface RbxRocketPropulsion extends RbxBodyMover {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "RocketPropulsion";
	CartoonFactor: number;
	MaxSpeed: number;
	MaxThrust: number;
	MaxTorque: Vector3;
	Target?: BasePart;
	TargetOffset: Vector3;
	TargetRadius: number;
	ThrustD: number;
	ThrustP: number;
	TurnD: number;
	TurnP: number;
	Abort(): void;
	Fire(): void;
	readonly ReachedTarget: RBXScriptSignal<() => void>;
}
type RocketPropulsion = RbxRocketPropulsion & Indexable<RbxRocketPropulsion>;

// BrowserService
interface RbxBrowserService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "BrowserService";
}
type BrowserService = RbxBrowserService & Indexable<RbxBrowserService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "BrowserService"): BrowserService;
}

// CacheableContentProvider
interface RbxCacheableContentProvider extends RbxInstance {
}
type CacheableContentProvider = MeshContentProvider | SolidModelContentProvider;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "CacheableContentProvider"): CacheableContentProvider;
}

// MeshContentProvider
interface RbxMeshContentProvider extends RbxCacheableContentProvider {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "MeshContentProvider";
}
type MeshContentProvider = RbxMeshContentProvider & Indexable<RbxMeshContentProvider>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "MeshContentProvider"): MeshContentProvider;
}

// SolidModelContentProvider
interface RbxSolidModelContentProvider extends RbxCacheableContentProvider {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "SolidModelContentProvider";
}
type SolidModelContentProvider = RbxSolidModelContentProvider & Indexable<RbxSolidModelContentProvider>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "SolidModelContentProvider"): SolidModelContentProvider;
}

// Camera
interface RbxCamera extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Camera";
	/** The current position and rotation of the Camera.  For most CameraTypes, the rotation is set such that the CoordinateFrame lookVector is pointing at the Focus. */
	CFrame: CFrame;
	/** Defines how the camera will behave. [More info](http://wiki.roblox.com/index.php/CameraType) */
	CameraType: Enum.CameraType;
	/** The current angle, or width, of what the camera can see.  Current acceptable values are from 20 degrees to 80. */
	FieldOfView: number;
	/** The current CoordinateFrame that the camera is looking at.  Note: it is not always guaranteed that the camera is always looking here. */
	Focus: CFrame;
	HeadLocked: boolean;
	HeadScale: number;
	/** The negative z-offset of the view frustum's near clipping plane. */
	readonly NearPlaneZ: number;
	/** Holds the x,y screen resolution of the viewport the camera is presenting (note: this can differ from the AbsoluteSize property of a full screen gui). */
	readonly ViewportSize: Vector2;
	GetLargestCutoffDistance(ignoreList: Array<Instance>): number;
	GetPanSpeed(): number;
	GetRenderCFrame(): CFrame;
	/** Returns the camera's current roll. Roll is defined in radians, and is stored as the delta from the camera's y axis default normal vector. */
	GetRoll(): number;
	GetTiltSpeed(): number;
	Interpolate(endPos: CFrame, endFocus: CFrame, duration: number): void;
	PanUnits(units: number): void;
	/** Takes a 2D screen position and produces a Ray object to be used for 3D raycasting. Input is x,y screen coordinates, and a (optional, defaults to 0) z position which sets how far in the camera look vector to start the ray origin. */
	ScreenPointToRay(x: number, y: number, depth?: number): Ray;
	SetCameraPanMode(mode?: Enum.CameraPanMode): void;
	/** Sets the camera's current roll. Roll is defined in radians, and is stored as the delta from the camera's y axis default normal vector. */
	SetRoll(rollAngle: number): void;
	TiltUnits(units: number): boolean;
	/** Same as ScreenPointToRay, except no GUI offsets are taken into account. Useful for things like casting a ray from the middle of the Camera.ViewportSize */
	ViewportPointToRay(x: number, y: number, depth?: number): Ray;
	readonly InterpolationFinished: RBXScriptSignal<() => void>;
}
type Camera = RbxCamera & Indexable<RbxCamera>;

// ChangeHistoryService
interface RbxChangeHistoryService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ChangeHistoryService";
}
type ChangeHistoryService = RbxChangeHistoryService & Indexable<RbxChangeHistoryService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "ChangeHistoryService"): ChangeHistoryService;
}

// CharacterAppearance
interface RbxCharacterAppearance extends RbxInstance {
}
type CharacterAppearance = BodyColors | CharacterMesh | Clothing | ShirtGraphic | Skin;

// BodyColors
interface RbxBodyColors extends RbxCharacterAppearance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "BodyColors";
	HeadColor: BrickColor;
	HeadColor3: Color3;
	LeftArmColor: BrickColor;
	LeftArmColor3: Color3;
	LeftLegColor: BrickColor;
	LeftLegColor3: Color3;
	RightArmColor: BrickColor;
	RightArmColor3: Color3;
	RightLegColor: BrickColor;
	RightLegColor3: Color3;
	TorsoColor: BrickColor;
	TorsoColor3: Color3;
}
type BodyColors = RbxBodyColors & Indexable<RbxBodyColors>;

// CharacterMesh
interface RbxCharacterMesh extends RbxCharacterAppearance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "CharacterMesh";
	BaseTextureId: number;
	BodyPart: Enum.BodyPart;
	MeshId: number;
	OverlayTextureId: number;
}
type CharacterMesh = RbxCharacterMesh & Indexable<RbxCharacterMesh>;

// Clothing
interface RbxClothing extends RbxCharacterAppearance {
	Color3: Color3;
}
type Clothing = Pants | Shirt;

// Pants
interface RbxPants extends RbxClothing {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Pants";
	PantsTemplate: string;
}
type Pants = RbxPants & Indexable<RbxPants>;

// Shirt
interface RbxShirt extends RbxClothing {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Shirt";
	ShirtTemplate: string;
}
type Shirt = RbxShirt & Indexable<RbxShirt>;

// ShirtGraphic
interface RbxShirtGraphic extends RbxCharacterAppearance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ShirtGraphic";
	Color3: Color3;
	Graphic: string;
}
type ShirtGraphic = RbxShirtGraphic & Indexable<RbxShirtGraphic>;

// Skin
interface RbxSkin extends RbxCharacterAppearance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Skin";
	SkinColor: BrickColor;
}
type Skin = RbxSkin & Indexable<RbxSkin>;

// Chat
interface RbxChat extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Chat";
	BubbleChatEnabled: boolean;
	readonly LoadDefaultChat: boolean;
	InvokeChatCallback(callbackType: Enum.ChatCallbackType, callbackArguments: Array<any>): unknown;
	RegisterChatCallback(callbackType: Enum.ChatCallbackType, callbackFunction: Function): void;
	CanUserChatAsync(userId: number): boolean;
	CanUsersChatAsync(userIdFrom: number, userIdTo: number): boolean;
}
type Chat = RbxChat & Indexable<RbxChat>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "Chat"): Chat;
}

// ClickDetector
interface RbxClickDetector extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ClickDetector";
	CursorIcon: string;
	/** The maximum distance a Player's character can be from the ClickDetector's parent Part that will allow the Player's mouse to fire events on this object. */
	MaxActivationDistance: number;
}
type ClickDetector = RbxClickDetector & Indexable<RbxClickDetector>;

// ClusterPacketCache
interface RbxClusterPacketCache extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ClusterPacketCache";
}
type ClusterPacketCache = RbxClusterPacketCache & Indexable<RbxClusterPacketCache>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "ClusterPacketCache"): ClusterPacketCache;
}

// CollectionService
interface RbxCollectionService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "CollectionService";
	/** Adds a tag to an instance. */
	AddTag(instance: Instance, tag: string): void;
	/** Returns whether the given instance has the given tag. */
	HasTag(instance: Instance, tag: string): boolean;
	/** Removes a tag to an instance. */
	RemoveTag(instance: Instance, tag: string): void;
}
type CollectionService = RbxCollectionService & Indexable<RbxCollectionService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "CollectionService"): CollectionService;
}

// Configuration
interface RbxConfiguration extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Configuration";
}
type Configuration = RbxConfiguration & Indexable<RbxConfiguration>;

// Constraint
interface RbxConstraint extends RbxInstance {
	/** Read-only boolean, true if the Constraint is active in world. */
	readonly Active: boolean;
	Attachment0?: Attachment;
	Attachment1?: Attachment;
	/** The color of the in-game visual. */
	Color: BrickColor;
	/** Toggles whether or not this constraint is enabled. Disabled constraints will not render in game. */
	Enabled: boolean;
	/** Toggles the in-game visual associated with this constraint. */
	Visible: boolean;
}
type Constraint = AlignOrientation | AlignPosition | BallSocketConstraint | HingeConstraint | LineForce | RodConstraint | RopeConstraint | SlidingBallConstraint | SpringConstraint | Torque | VectorForce;

// AlignOrientation
interface RbxAlignOrientation extends RbxConstraint {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "AlignOrientation";
	AlignType: Enum.AlignType;
	MaxAngularVelocity: number;
	MaxTorque: number;
	PrimaryAxisOnly: boolean;
	ReactionTorqueEnabled: boolean;
	Responsiveness: number;
	RigidityEnabled: boolean;
}
type AlignOrientation = RbxAlignOrientation & Indexable<RbxAlignOrientation>;

// AlignPosition
interface RbxAlignPosition extends RbxConstraint {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "AlignPosition";
	ApplyAtCenterOfMass: boolean;
	MaxForce: number;
	MaxVelocity: number;
	ReactionForceEnabled: boolean;
	Responsiveness: number;
	RigidityEnabled: boolean;
}
type AlignPosition = RbxAlignPosition & Indexable<RbxAlignPosition>;

// BallSocketConstraint
interface RbxBallSocketConstraint extends RbxConstraint {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "BallSocketConstraint";
	/** Enables the angular limit between the axis of Attachment0 and the axis of Attachment1. */
	LimitsEnabled: boolean;
	/** Radius of the in-game visual. Value in [0, inf). */
	Radius: number;
	/** Restitution of the limit, or how elastic it is. Value in [0, 1]. */
	Restitution: number;
	/** Enables the angular limits around the main axis of Attachment1. */
	TwistLimitsEnabled: boolean;
	/** Lower angular limit around the axis of Attachment1. Value in [-180, 180]. */
	TwistLowerAngle: number;
	/** Upper angular limit around the axis of Attachment1. Value in [-180, 180]. */
	TwistUpperAngle: number;
	/** Maximum angle between the two main axes. Value in [0, 180]. */
	UpperAngle: number;
}
type BallSocketConstraint = RbxBallSocketConstraint & Indexable<RbxBallSocketConstraint>;

// HingeConstraint
interface RbxHingeConstraint extends RbxConstraint {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "HingeConstraint";
	/** Type of the rotational actuator: None, Motor, or Servo.  */
	ActuatorType: Enum.ActuatorType;
	/** Target angular speed. This value is unsigned as the servo will always move toward its target. Value in [0, inf). */
	AngularSpeed: number;
	/** The target angular velocity of the motor in radians per second around the rotation axis. Value in [0, inf). */
	AngularVelocity: number;
	/** Signed angle between the SecondaryAxis of Attchement0 and the SecondaryAxis of Attachment1 around the rotation axis. Value in [-180, 180]. */
	readonly CurrentAngle: number;
	/** Enables the angular limits on rotations around the main axis of Attachment0. */
	LimitsEnabled: boolean;
	/** Lower limit for the angle from the SecondaryAxis of Attachment0 to the SecondaryAxis of Attachment1 around the rotation axis. Value in [-180, 180]. */
	LowerAngle: number;
	/** The maximum angular acceleration of the motor in radians per second square. Value in [0, inf). */
	MotorMaxAcceleration: number;
	/** The maximum torque the motor can apply to achieve the target angular velocity. Value in [0, inf). */
	MotorMaxTorque: number;
	/** Radius of the in-game visual. Value in [0, inf). */
	Radius: number;
	Restitution: number;
	/** Maximum torque the servo motor can apply. Value in [0, inf). */
	ServoMaxTorque: number;
	/** Target angle for the SecondaryAxis of Attachment1 from the SecondaryAxis of Attachment0 around the rotation axis. Value in [-180, 180]. */
	TargetAngle: number;
	/** Upper limit for the angle from the SecondaryAxis of Attachment0 to the SecondaryAxis of Attachment1 around the rotation axis. Value in [-180, 180]. */
	UpperAngle: number;
}
type HingeConstraint = RbxHingeConstraint & Indexable<RbxHingeConstraint>;

// LineForce
interface RbxLineForce extends RbxConstraint {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "LineForce";
	ApplyAtCenterOfMass: boolean;
	InverseSquareLaw: boolean;
	Magnitude: number;
	MaxForce: number;
	ReactionForceEnabled: boolean;
}
type LineForce = RbxLineForce & Indexable<RbxLineForce>;

// RodConstraint
interface RbxRodConstraint extends RbxConstraint {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "RodConstraint";
	/** Current distance between the two attachments. Value in [0, inf). */
	readonly CurrentDistance: number;
	/** The length of the rod or the distance to be maintained between the two attachments. Value in [0, inf). */
	Length: number;
	/** The thickness of the in-game visual (diameter). Value in [0, inf). */
	Thickness: number;
}
type RodConstraint = RbxRodConstraint & Indexable<RbxRodConstraint>;

// RopeConstraint
interface RbxRopeConstraint extends RbxConstraint {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "RopeConstraint";
	/** Current distance between the two attachments. Value in [0, inf). */
	readonly CurrentDistance: number;
	/** The length of the rope or the maximum distance between the two attachments. Value in [0, inf). */
	Length: number;
	/** Restitution of the rope, or how elastic it is. Value in [0, 1]. */
	Restitution: number;
	/** The thickness of the in-game visual (diameter). Value in [0, inf). */
	Thickness: number;
}
type RopeConstraint = RbxRopeConstraint & Indexable<RbxRopeConstraint>;

// SlidingBallConstraint
interface RbxSlidingBallConstraint extends RbxConstraint {
	/** Type of linear actuator (along the axis of the slider): None, Motor, or Servo. */
	ActuatorType: Enum.ActuatorType;
	/** Current position of Attachment1 with respect to Attachment0 along the slider axis. Value in (-inf, inf). */
	readonly CurrentPosition: number;
	/** Enables the limits on the linear motion along the axis of the slider. */
	LimitsEnabled: boolean;
	/** Lower limit for the position of Attachment1 with respect to Attachment0 along the slider axis. Value in (-inf, inf). */
	LowerLimit: number;
	/** The maximum acceleration of the motor in studs per second squared. Value in [0, inf). */
	MotorMaxAcceleration: number;
	/** The maximum force the motor can apply to achieve the target velocity. Units are mass * studs / seconds^2. Value in [0, inf). */
	MotorMaxForce: number;
	/** Restitution of the two limits, or how elastic they are. Value in [0, 1]. */
	Restitution: number;
	/** Maximum force the servo motor can apply. Units are mass * studs / seconds^2. Value in [0, inf). */
	ServoMaxForce: number;
	/** Size of the in-game visual associated with this constraint. Value in [0, inf). */
	Size: number;
	/** Target speed in studs per second. This value is unsigned as the servo will always move toward its target. Value in [0, inf). */
	Speed: number;
	/** Target position of Attachment1 with respect to Attachment0 along the slider axis. Value in (-inf, inf). */
	TargetPosition: number;
	/** Upper limit for the position of Attachment1 with respect to Attachment0 along the slider axis. Value in (-inf, inf). */
	UpperLimit: number;
	/** The target linear velocity of the motor in studs per second along the slider axis. Value in (-inf, inf). */
	Velocity: number;
}
type SlidingBallConstraint = CylindricalConstraint | PrismaticConstraint;

// CylindricalConstraint
interface RbxCylindricalConstraint extends RbxSlidingBallConstraint {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "CylindricalConstraint";
	/** Type of angular actuator: None, Motor, or Servo.  */
	AngularActuatorType: Enum.ActuatorType;
	/** Enables the angular limits around the rotation axis. */
	AngularLimitsEnabled: boolean;
	/** Restitution of the two limits, or how elastic they are. Value in [0, 1].  */
	AngularRestitution: number;
	/** Target angular speed. This value is unsigned as the servo will always move toward its target. In radians per second. Value in [0, inf).  */
	AngularSpeed: number;
	/** The target angular velocity of the motor in radians per second around the rotation axis. Value in [0, inf). */
	AngularVelocity: number;
	/** Signed angle (in degrees) between the reference axis and the secondary axis of Attachment1 around the rotation axis. Value in [-180, 180].  */
	readonly CurrentAngle: number;
	/** Direction of the rotation axis as an angle from the x-axis in the xy-plane of Attachment0. Value in [-180, 180].  */
	InclinationAngle: number;
	/** Lower limit for the angle (in degrees) between the reference axis and the SecondaryAxis of Attachment1 around the rotation axis. Value in [-180, 180]. */
	LowerAngle: number;
	/** The maximum angular acceleration of the motor in radians per second squared. Value in [0, inf). */
	MotorMaxAngularAcceleration: number;
	/** The maximum torque the motor can apply to achieve the target angular velocity. The units are mass * studs^2 / second^2. Value in [0, inf). */
	MotorMaxTorque: number;
	/** Enable the visibility of the rotation axis. */
	RotationAxisVisible: boolean;
	/** Maximum torque the servo motor can apply. The units are mass * studs^2 / second^2. Value in [0, inf).  */
	ServoMaxTorque: number;
	/**  Target angle (in degrees) between the reference axis and the secondary axis of Attachment1 around the rotation axis. Value in [-180, 180]. */
	TargetAngle: number;
	/** Upper limit for the angle (in degrees) between the reference axis and the SecondaryAxis of Attachment1 around the rotation axis. Value in [-180, 180].  */
	UpperAngle: number;
	/** The unit vector direction of the rotation axis in world coordinates. */
	readonly WorldRotationAxis: Vector3;
}
type CylindricalConstraint = RbxCylindricalConstraint & Indexable<RbxCylindricalConstraint>;

// PrismaticConstraint
interface RbxPrismaticConstraint extends RbxSlidingBallConstraint {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "PrismaticConstraint";
}
type PrismaticConstraint = RbxPrismaticConstraint & Indexable<RbxPrismaticConstraint>;

// SpringConstraint
interface RbxSpringConstraint extends RbxConstraint {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "SpringConstraint";
	/** The number of coils in the in-game visual. Value in [0, 8]. */
	Coils: number;
	/** Current distance between the two attachments. Value in [0, inf). */
	readonly CurrentLength: number;
	/** The damping parameter of the spring. The force is scaled with respect to relative velocity. The units of this property are force / velocity. Value in [0, inf). */
	Damping: number;
	/** The distance (in studs) between the two attachments at which the spring exerts no stiffness force. Value in [0, inf). */
	FreeLength: number;
	/** Enables limits on the length of the spring. */
	LimitsEnabled: boolean;
	/** The maximum force that the spring can apply. Useful to prevent instabilities. The units are mass * studs / seconds^2. Value in [0, inf). */
	MaxForce: number;
	/** Maximum spring length, or the maxium distance between the two attachments. Value in [0, inf). */
	MaxLength: number;
	/** Minimum spring length, or the minimum distance between the two attachments. Value in [0, inf). */
	MinLength: number;
	/** The radius of the in-game spring coil visual. Value in [0, inf). */
	Radius: number;
	/** The stiffness parameter of the spring. Force is scaled based on distance from the free length. The units of this property are force / distance. Value in [0, inf). */
	Stiffness: number;
	/** The thickness of the spring wire (diameter) in the in-game visual. Value in [0, inf). */
	Thickness: number;
}
type SpringConstraint = RbxSpringConstraint & Indexable<RbxSpringConstraint>;

// Torque
interface RbxTorque extends RbxConstraint {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Torque";
	RelativeTo: Enum.ActuatorRelativeTo;
	Torque: Vector3;
}
type Torque = RbxTorque & Indexable<RbxTorque>;

// VectorForce
interface RbxVectorForce extends RbxConstraint {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "VectorForce";
	ApplyAtCenterOfMass: boolean;
	Force: Vector3;
	RelativeTo: Enum.ActuatorRelativeTo;
}
type VectorForce = RbxVectorForce & Indexable<RbxVectorForce>;

// ContentProvider
interface RbxContentProvider extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ContentProvider";
	readonly BaseUrl: string;
	readonly RequestQueueSize: number;
}
type ContentProvider = RbxContentProvider & Indexable<RbxContentProvider>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "ContentProvider"): ContentProvider;
}

// ContextActionService
interface RbxContextActionService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ContextActionService";
	BindActivate(userInputTypeForActivation: Enum.UserInputType, keyCodeForActivation?: Enum.KeyCode): void;
	/** Returns a table with all bound action info. Each entry is a key with 'actionName' and value being the same table you would get from ContextActionService:GetBoundActionInfo('actionName'). */
	GetAllBoundActionInfo(): object;
	/** Returns a table with info regarding the function bound with 'actionName'. Table has the keys 'title' (current title that was set with SetTitle) 'image' (image set with SetImage) 'description' (description set with SetDescription) 'inputTypes' (tuple containing all input bound for this 'actionName') 'createTouchButton' (whether or not we created a touch button for this 'actionName').  */
	GetBoundActionInfo(actionName: string): object;
	GetCurrentLocalToolIcon(): string;
	/** If 'actionName' key contains a bound action, then 'description' is set as the description of the bound action. This description will appear for users in a listing of current actions availables. */
	SetDescription(actionName: string, description: string): void;
	/** If 'actionName' key contains a bound action, then 'image' is set as the image of the touch button. Does nothing if a touch button was not created. No guarantees are made whether image will be set when button is manipulated. */
	SetImage(actionName: string, image: string): void;
	/** If 'actionName' key contains a bound action, then 'position' is set as the position of the touch button. Does nothing if a touch button was not created. No guarantees are made whether position will be set when button is manipulated. */
	SetPosition(actionName: string, position: UDim2): void;
	/** If 'actionName' key contains a bound action, then 'title' is set as the title of the touch button. Does nothing if a touch button was not created. No guarantees are made whether title will be set when button is manipulated. */
	SetTitle(actionName: string, title: string): void;
	/** If 'actionName' key contains a bound action, removes function from being called by all input that it was bound by (if function was also bound by a different action name as well, those bound input are still active). Will also remove any touch button created (if button was manipulated manually there is no guarantee it will be cleaned up). */
	UnbindAction(actionName: string): void;
	UnbindActivate(userInputTypeForActivation: Enum.UserInputType, keyCodeForActivation?: Enum.KeyCode): void;
	/** Removes all functions bound. No actionNames will remain. All touch buttons will be removed. If button was manipulated manually there is no guarantee it will be cleaned up. */
	UnbindAllActions(): void;
}
type ContextActionService = RbxContextActionService & Indexable<RbxContextActionService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "ContextActionService"): ContextActionService;
}

// Controller
interface RbxController extends RbxInstance {
	BindButton(button: Enum.Button, caption: string): void;
	GetButton(button: Enum.Button): boolean;
	UnbindButton(button: Enum.Button): void;
	readonly ButtonChanged: RBXScriptSignal<(button: Enum.Button) => void>;
}
type Controller = HumanoidController | SkateboardController | VehicleController;

// HumanoidController
interface RbxHumanoidController extends RbxController {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "HumanoidController";
}
type HumanoidController = RbxHumanoidController & Indexable<RbxHumanoidController>;

// SkateboardController
interface RbxSkateboardController extends RbxController {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "SkateboardController";
	readonly Steer: number;
	readonly Throttle: number;
	readonly AxisChanged: RBXScriptSignal<(axis: string) => void>;
}
type SkateboardController = RbxSkateboardController & Indexable<RbxSkateboardController>;

// VehicleController
interface RbxVehicleController extends RbxController {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "VehicleController";
}
type VehicleController = RbxVehicleController & Indexable<RbxVehicleController>;

// ControllerService
interface RbxControllerService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ControllerService";
}
type ControllerService = RbxControllerService & Indexable<RbxControllerService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "ControllerService"): ControllerService;
}

// CookiesService
interface RbxCookiesService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "CookiesService";
}
type CookiesService = RbxCookiesService & Indexable<RbxCookiesService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "CookiesService"): CookiesService;
}

// CorePackages
interface RbxCorePackages extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "CorePackages";
}
type CorePackages = RbxCorePackages & Indexable<RbxCorePackages>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "CorePackages"): CorePackages;
}

// CoreScriptSyncService
interface RbxCoreScriptSyncService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "CoreScriptSyncService";
}
type CoreScriptSyncService = RbxCoreScriptSyncService & Indexable<RbxCoreScriptSyncService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "CoreScriptSyncService"): CoreScriptSyncService;
}

// CustomEvent
interface RbxCustomEvent extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "CustomEvent";
	GetAttachedReceivers(): Array<Instance>;
	SetValue(newValue: number): void;
	readonly ReceiverConnected: RBXScriptSignal<(receiver: Instance) => void>;
	readonly ReceiverDisconnected: RBXScriptSignal<(receiver: Instance) => void>;
}
type CustomEvent = RbxCustomEvent & Indexable<RbxCustomEvent>;

// CustomEventReceiver
interface RbxCustomEventReceiver extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "CustomEventReceiver";
	Source?: Instance;
	GetCurrentValue(): number;
	readonly EventConnected: RBXScriptSignal<(event: Instance) => void>;
	readonly EventDisconnected: RBXScriptSignal<(event: Instance) => void>;
	readonly SourceValueChanged: RBXScriptSignal<(newValue: number) => void>;
}
type CustomEventReceiver = RbxCustomEventReceiver & Indexable<RbxCustomEventReceiver>;

// DataModelMesh
interface RbxDataModelMesh extends RbxInstance {
	Offset: Vector3;
	Scale: Vector3;
	VertexColor: Vector3;
}
type DataModelMesh = BevelMesh | DerivesFromFileMesh;

// BevelMesh
interface RbxBevelMesh extends RbxDataModelMesh {
}
type BevelMesh = BlockMesh | CylinderMesh;

// BlockMesh
interface RbxBlockMesh extends RbxBevelMesh {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "BlockMesh";
}
type BlockMesh = RbxBlockMesh & Indexable<RbxBlockMesh>;

// CylinderMesh
interface RbxCylinderMesh extends RbxBevelMesh {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "CylinderMesh";
}
type CylinderMesh = RbxCylinderMesh & Indexable<RbxCylinderMesh>;

// DerivesFromFileMesh
interface RbxDerivesFromFileMesh extends RbxDataModelMesh {
	MeshId: string;
	TextureId: string;
}
interface RbxFileMesh extends RbxDerivesFromFileMesh {
	readonly ClassName: "FileMesh";
}

type FileMesh = RbxFileMesh & Indexable<RbxFileMesh>;
type DerivesFromFileMesh = FileMesh | SpecialMesh;

// SpecialMesh
interface RbxSpecialMesh extends RbxDerivesFromFileMesh {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "SpecialMesh";
	MeshType: Enum.MeshType;
}
type SpecialMesh = RbxSpecialMesh & Indexable<RbxSpecialMesh>;

// DataStoreService
interface RbxDataStoreService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "DataStoreService";
	GetRequestBudgetForRequestType(requestType: Enum.DataStoreRequestType): number;
}
type DataStoreService = RbxDataStoreService & Indexable<RbxDataStoreService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "DataStoreService"): DataStoreService;
}

// Debris
interface RbxDebris extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Debris";
	/** Adds an Instance into the debris service that will later be destroyed.  Second argument 'lifetime' is optional and specifies how long (in seconds) to wait before destroying the item. If no time is specified then the item added will automatically be destroyed in 10 seconds. */
	AddItem(item: Instance, lifetime?: number): void;
}
type Debris = RbxDebris & Indexable<RbxDebris>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "Debris"): Debris;
}

// DebugSettings
interface RbxDebugSettings extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "DebugSettings";
	readonly DataModel: number;
	ErrorReporting: Enum.ErrorReporting;
	readonly GfxCard: string;
	readonly InstanceCount: number;
	IsFmodProfilingEnabled: boolean;
	IsScriptStackTracingEnabled: boolean;
	readonly JobCount: number;
	LuaRamLimit: number;
	readonly OsIs64Bit: boolean;
	readonly OsPlatform: string;
	readonly OsPlatformId: number;
	readonly OsVer: string;
	readonly PlayerCount: number;
	ReportSoundWarnings: boolean;
	readonly RobloxProductName: string;
	readonly RobloxVersion: string;
	readonly SIMD: string;
	readonly SystemProductName: string;
	TickCountPreciseOverride: Enum.TickCountSampleMethod;
	readonly VideoMemory: number;
}
type DebugSettings = RbxDebugSettings & Indexable<RbxDebugSettings>;

// DebuggerBreakpoint
interface RbxDebuggerBreakpoint extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "DebuggerBreakpoint";
	Condition: string;
	IsEnabled: boolean;
	readonly Line: number;
}
type DebuggerBreakpoint = RbxDebuggerBreakpoint & Indexable<RbxDebuggerBreakpoint>;

// DebuggerManager
interface RbxDebuggerManager extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "DebuggerManager";
	readonly DebuggingEnabled: boolean;
	AddDebugger(script: Instance): Instance | undefined;
	GetDebuggers(): Array<Instance>;
	Resume(): void;
	StepIn(): void;
	StepOut(): void;
	StepOver(): void;
	readonly DebuggerAdded: RBXScriptSignal<(debug: Instance) => void>;
	readonly DebuggerRemoved: RBXScriptSignal<(debug: Instance) => void>;
}
type DebuggerManager = RbxDebuggerManager & Indexable<RbxDebuggerManager>;

// DebuggerWatch
interface RbxDebuggerWatch extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "DebuggerWatch";
	Expression: string;
	CheckSyntax(): void;
}
type DebuggerWatch = RbxDebuggerWatch & Indexable<RbxDebuggerWatch>;

// Dialog
interface RbxDialog extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Dialog";
	/** Indicates how the dialog may be used by players. Use Enum.DialogBehaviorType.SinglePlayer if only one player should interact with the dialog at a time, otherwise use Enum.DialogBehaviorType.MultiplePlayers. */
	BehaviorType: Enum.DialogBehaviorType;
	/** The maximum distance that the player's character can be from the dialog's parent in order to use the dialog. */
	ConversationDistance: number;
	/** Indicates whether or not an extra choice is available for the player to exit the dialog tree at this node. */
	GoodbyeChoiceActive: boolean;
	/** The prompt text for an extra choice that allows the player to exit the dialog tree at this node. */
	GoodbyeDialog: string;
	/** Indicates whether or not the dialog is currently being used by one or more players. */
	InUse: boolean;
	/** The chat message that is displayed to the player when they first activate the dialog. */
	InitialPrompt: string;
	/** Describes the purpose of the dialog, which is used to display a relevant icon on the dialog's activation button. */
	Purpose: Enum.DialogPurpose;
	/** Describes the tone of the dialog, which is used to display a relevant color in the dialog interface. */
	Tone: Enum.DialogTone;
	TriggerDistance: number;
	TriggerOffset: Vector3;
}
type Dialog = RbxDialog & Indexable<RbxDialog>;

// DialogChoice
interface RbxDialogChoice extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "DialogChoice";
	GoodbyeChoiceActive: boolean;
	GoodbyeDialog: string;
	ResponseDialog: string;
	UserDialog: string;
}
type DialogChoice = RbxDialogChoice & Indexable<RbxDialogChoice>;

// Dragger
interface RbxDragger extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Dragger";
	AxisRotate(axis?: Enum.Axis): void;
	MouseDown(mousePart: Instance, pointOnMousePart: Vector3, parts: Array<Instance>): void;
	MouseMove(mouseRay: Ray): void;
	MouseUp(): void;
}
type Dragger = RbxDragger & Indexable<RbxDragger>;

// Explosion
interface RbxExplosion extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Explosion";
	/** How much force this Explosion exerts on objects within it's BlastRadius. Setting this to 0 creates a purely graphical effect. A larger number will cause Parts to fly away at higher velocities. */
	BlastPressure: number;
	/** How big the Explosion is. This is a circle starting from the center of the Explosion's Position, the larger this property the larger the circle of destruction. */
	BlastRadius: number;
	DestroyJointRadiusPercent: number;
	/** Defines the behavior of the Explosion. [More info](http://wiki.roblox.com/index.php/ExplosionType) */
	ExplosionType: Enum.ExplosionType;
	/** Where the Explosion occurs in absolute world coordinates. */
	Position: Vector3;
	Visible: boolean;
	readonly Hit: RBXScriptSignal<(part: Instance, distance: number) => void>;
}
type Explosion = RbxExplosion & Indexable<RbxExplosion>;

// FaceInstance
interface RbxFaceInstance extends RbxInstance {
	Face: Enum.NormalId;
}
type FaceInstance = DerivesFromDecal;

// DerivesFromDecal
interface RbxDerivesFromDecal extends RbxFaceInstance {
	Color3: Color3;
	LocalTransparencyModifier: number;
	Texture: string;
	Transparency: number;
}
interface RbxDecal extends RbxDerivesFromDecal {
	readonly ClassName: "Decal";
}

type Decal = RbxDecal & Indexable<RbxDecal>;
type DerivesFromDecal = Decal | Texture;

// Texture
interface RbxTexture extends RbxDerivesFromDecal {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Texture";
	StudsPerTileU: number;
	StudsPerTileV: number;
}
type Texture = RbxTexture & Indexable<RbxTexture>;

// Feature
interface RbxFeature extends RbxInstance {
	FaceId: Enum.NormalId;
	InOut: Enum.InOut;
	LeftRight: Enum.LeftRight;
	TopBottom: Enum.TopBottom;
}
type Feature = Hole | MotorFeature;

// Hole
interface RbxHole extends RbxFeature {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Hole";
}
type Hole = RbxHole & Indexable<RbxHole>;

// MotorFeature
interface RbxMotorFeature extends RbxFeature {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "MotorFeature";
}
type MotorFeature = RbxMotorFeature & Indexable<RbxMotorFeature>;

// File
interface RbxFile extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "File";
}
type File = RbxFile & Indexable<RbxFile>;

// Fire
interface RbxFire extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Fire";
	/** The color of the base of the fire.  See SecondaryColor for more. */
	Color: Color3;
	Enabled: boolean;
	/** How hot the fire appears to be. The flame moves quicker the higher this value is set. */
	Heat: number;
	/** The color the fire interpolates to from Color. The longer a particle exists in the fire, the close to this color it becomes. */
	SecondaryColor: Color3;
	/** How large the fire appears to be. */
	Size: number;
}
type Fire = RbxFire & Indexable<RbxFire>;

// FlagStandService
interface RbxFlagStandService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "FlagStandService";
}
type FlagStandService = RbxFlagStandService & Indexable<RbxFlagStandService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "FlagStandService"): FlagStandService;
}

// FlyweightService
interface RbxFlyweightService extends RbxInstance {
}
type FlyweightService = CSGDictionaryService | NonReplicatedCSGDictionaryService;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "FlyweightService"): FlyweightService;
}

// CSGDictionaryService
interface RbxCSGDictionaryService extends RbxFlyweightService {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "CSGDictionaryService";
}
type CSGDictionaryService = RbxCSGDictionaryService & Indexable<RbxCSGDictionaryService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "CSGDictionaryService"): CSGDictionaryService;
}

// NonReplicatedCSGDictionaryService
interface RbxNonReplicatedCSGDictionaryService extends RbxFlyweightService {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "NonReplicatedCSGDictionaryService";
}
type NonReplicatedCSGDictionaryService = RbxNonReplicatedCSGDictionaryService & Indexable<RbxNonReplicatedCSGDictionaryService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "NonReplicatedCSGDictionaryService"): NonReplicatedCSGDictionaryService;
}

// Folder
interface RbxFolder extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Folder";
}
type Folder = RbxFolder & Indexable<RbxFolder>;

// ForceField
interface RbxForceField extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ForceField";
	Visible: boolean;
}
type ForceField = RbxForceField & Indexable<RbxForceField>;

// FriendService
interface RbxFriendService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "FriendService";
}
type FriendService = RbxFriendService & Indexable<RbxFriendService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "FriendService"): FriendService;
}

// FunctionalTest
interface RbxFunctionalTest extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "FunctionalTest";
	Description: string;
	Error(message?: string): void;
	Failed(message?: string): void;
	Pass(message?: string): void;
	Passed(message?: string): void;
	Warn(message?: string): void;
}
type FunctionalTest = RbxFunctionalTest & Indexable<RbxFunctionalTest>;

// GamePassService
interface RbxGamePassService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "GamePassService";
}
type GamePassService = RbxGamePassService & Indexable<RbxGamePassService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "GamePassService"): GamePassService;
}

// GameSettings
interface RbxGameSettings extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "GameSettings";
	AdditionalCoreIncludeDirs: string;
	BubbleChatLifetime: number;
	BubbleChatMaxBubbles: number;
	ChatHistory: number;
	ChatScrollLength: number;
	HardwareMouse: boolean;
	OverrideStarterScript: string;
	ReportAbuseChatHistory: number;
	SoftwareSound: boolean;
	VideoCaptureEnabled: boolean;
	VideoQuality: Enum.VideoQualitySettings;
}
type GameSettings = RbxGameSettings & Indexable<RbxGameSettings>;

// GamepadService
interface RbxGamepadService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "GamepadService";
}
type GamepadService = RbxGamepadService & Indexable<RbxGamepadService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "GamepadService"): GamepadService;
}

// Geometry
interface RbxGeometry extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Geometry";
}
type Geometry = RbxGeometry & Indexable<RbxGeometry>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "Geometry"): Geometry;
}

// GlobalDataStore
interface RbxGlobalDataStore extends RbxInstance {
	/** Sets the value of the key. This overwrites any existing data stored in the key */
	SetAsync(key: string, value?: any): void;
}
type GlobalDataStore = OrderedDataStore;

// OrderedDataStore
interface RbxOrderedDataStore extends RbxGlobalDataStore {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "OrderedDataStore";
}
type OrderedDataStore = RbxOrderedDataStore & Indexable<RbxOrderedDataStore>;

// GoogleAnalyticsConfiguration
interface RbxGoogleAnalyticsConfiguration extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "GoogleAnalyticsConfiguration";
}
type GoogleAnalyticsConfiguration = RbxGoogleAnalyticsConfiguration & Indexable<RbxGoogleAnalyticsConfiguration>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "GoogleAnalyticsConfiguration"): GoogleAnalyticsConfiguration;
}

// GroupService
interface RbxGroupService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "GroupService";
}
type GroupService = RbxGroupService & Indexable<RbxGroupService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "GroupService"): GroupService;
}

// GuiBase
interface RbxGuiBase extends RbxInstance {
}
type GuiBase = GuiBase2d | GuiBase3d;

// GuiBase2d
interface RbxGuiBase2d extends RbxGuiBase {
	/** A read-only Vector2 value that is the GuiObject's current position (x,y) in pixel space, from the top left corner of the GuiObject. */
	readonly AbsolutePosition: Vector2;
	readonly AbsoluteRotation: number;
	/** A read-only Vector2 value that is the GuiObject's current size (width, height) in pixel space. */
	readonly AbsoluteSize: Vector2;
	AutoLocalize: boolean;
	RootLocalizationTable?: LocalizationTable;
}
type GuiBase2d = GuiObject | LayerCollector;

// GuiObject
interface RbxGuiObject extends RbxGuiBase2d {
	/** If true, this GuiObject can fire mouse events and will pass them to any GuiObjects layered underneath, while false will do neither. */
	Active: boolean;
	AnchorPoint: Vector2;
	/** A Color3 value that specifies the background color for the GuiObject. This value is ignored if the Style property (not found on all GuiObjects) is set to something besides custom. */
	BackgroundColor3: Color3;
	/** A number value that specifies how transparent the background of the GuiObject is. This value is ignored if the Style property (not found on all GuiObjects) is set to something besides custom. */
	BackgroundTransparency: number;
	/** A Color3 value that specifies the color of the outline of the GuiObject. This value is ignored if the Style property (not found on all GuiObjects) is set to something besides custom. */
	BorderColor3: Color3;
	/** A number value that specifies the thickness (in pixels) of the outline of the GuiObject. Currently this value can only be set to either 0 or 1, any other number has no effect. This value is ignored if the Style property (not found on all GuiObjects) is set to something besides custom. */
	BorderSizePixel: number;
	/** If set to true, any descendants of this GuiObject will only render if contained within it's borders. If set to false, all descendants will render regardless of position. */
	ClipsDescendants: boolean;
	LayoutOrder: number;
	NextSelectionDown?: GuiObject;
	NextSelectionLeft?: GuiObject;
	NextSelectionRight?: GuiObject;
	NextSelectionUp?: GuiObject;
	/** A UDim2 value describing the position of the top-left corner of the GuiObject on screen. More information on UDim2 is available [here](http://wiki.roblox.com/index.php/UDim2). */
	Position: UDim2;
	Rotation: number;
	Selectable: boolean;
	/** Overrides the default selection adornment (used for gamepads). For best results, this should point to a GuiObject. */
	SelectionImageObject?: GuiObject;
	/** A UDim2 value describing the size of the GuiObject on screen in both absolute and relative coordinates. More information on UDim2 is available [here](http://wiki.roblox.com/index.php/UDim2). */
	Size: UDim2;
	/** The direction(s) that an object can be resized in. [More info](http://wiki.roblox.com/index.php/SizeConstraint). */
	SizeConstraint: Enum.SizeConstraint;
	Transparency: number;
	Visible: boolean;
	/** Describes the ordering in which overlapping GuiObjects will be drawn. A value of 1 is drawn first, while higher values are drawn in ascending order (each value draws over the last). */
	ZIndex: number;
	/** Smoothly moves a GuiObject from its current position to 'endPosition'. The only required argument is 'endPosition'. [More info](http://wiki.roblox.com/index.php/TweenPosition)  */
	TweenPosition(endPosition: UDim2, easingDirection?: Enum.EasingDirection, easingStyle?: Enum.EasingStyle, time?: number, override?: boolean, callback?: Function): boolean;
	/** Smoothly translates a GuiObject's current size to 'endSize'. The only required argument is 'endSize'. [More info](http://wiki.roblox.com/index.php/TweenSize)  */
	TweenSize(endSize: UDim2, easingDirection?: Enum.EasingDirection, easingStyle?: Enum.EasingStyle, time?: number, override?: boolean, callback?: Function): boolean;
	/** Smoothly translates a GuiObject's current size to 'endSize', and also smoothly translates the GuiObject's current position to 'endPosition'. The only required arguments are 'endSize' and 'endPosition'. [More info](http://wiki.roblox.com/index.php/TweenSizeAndPosition)  */
	TweenSizeAndPosition(endSize: UDim2, endPosition: UDim2, easingDirection?: Enum.EasingDirection, easingStyle?: Enum.EasingStyle, time?: number, override?: boolean, callback?: Function): boolean;
	/** Fired when the mouse enters a GuiObject, as long as the GuiObject is active (see active property for more detail). Arguments 'x', and 'y' specify the absolute pixel position of the mouse. */
	readonly MouseEnter: RBXScriptSignal<(x: number, y: number) => void>;
	/** Fired when the mouse leaves a GuiObject, as long as the GuiObject is active (see active property for more detail). Arguments 'x', and 'y' specify the absolute pixel position of the mouse. */
	readonly MouseLeave: RBXScriptSignal<(x: number, y: number) => void>;
	/** Fired when the mouse is inside a GuiObject and moves, as long as the GuiObject is active (see active property for more detail). Arguments 'x', and 'y' specify the absolute pixel position of the mouse. */
	readonly MouseMoved: RBXScriptSignal<(x: number, y: number) => void>;
	readonly MouseWheelBackward: RBXScriptSignal<(x: number, y: number) => void>;
	readonly MouseWheelForward: RBXScriptSignal<(x: number, y: number) => void>;
	readonly SelectionGained: RBXScriptSignal<() => void>;
	readonly SelectionLost: RBXScriptSignal<() => void>;
	/** Fired when a user swipes their fingers on a TouchEnabled device. 'swipeDirection' is an Enum.SwipeDirection, indicating the direction the user swiped. 'numberOfTouches' is an int that indicates how many touches were involved with the gesture.  This event only fires locally. */
	readonly TouchSwipe: RBXScriptSignal<(swipeDirection: Enum.SwipeDirection, numberOfTouches: number) => void>;
}
type GuiObject = Frame | GuiButton | GuiLabel | ScrollingFrame | TextBox | ViewportFrame;

// Frame
interface RbxFrame extends RbxGuiObject {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Frame";
	/** Determines how a frame will look. Uses Enum.FrameStyle. [More info](http://wiki.roblox.com/index.php?title=API:Enum/FrameStyle) */
	Style: Enum.FrameStyle;
}
type Frame = RbxFrame & Indexable<RbxFrame>;

// GuiButton
interface RbxGuiButton extends RbxGuiObject {
	/** Determines whether a button changes color automatically when reacting to mouse events. */
	AutoButtonColor: boolean;
	/** Allows the mouse to be free in first person mode. If a button with this property set to true is visible, the mouse is 'free' in first person mode. */
	Modal: boolean;
	Selected: boolean;
	/** Determines how a button will look, including mouse event states. Uses Enum.ButtonStyle. [More info](http://wiki.roblox.com/index.php?title=API:Class/GuiButton/Style) */
	Style: Enum.ButtonStyle;
	readonly Activated: RBXScriptSignal<(inputObject: Instance) => void>;
	/** Fired when the mouse is over the button, and the mouse down and up events fire without the mouse leaving the button. */
	readonly MouseButton1Click: RBXScriptSignal<() => void>;
	/** Fired when the mouse button is pushed down on a button. */
	readonly MouseButton1Down: RBXScriptSignal<(x: number, y: number) => void>;
	/** Fired when the mouse button is released on a button. */
	readonly MouseButton1Up: RBXScriptSignal<(x: number, y: number) => void>;
	/** This function currently does not work :( */
	readonly MouseButton2Click: RBXScriptSignal<() => void>;
	/** This function currently does not work :( */
	readonly MouseButton2Down: RBXScriptSignal<(x: number, y: number) => void>;
	/** This function currently does not work :( */
	readonly MouseButton2Up: RBXScriptSignal<(x: number, y: number) => void>;
}
type GuiButton = ImageButton | TextButton;

// ImageButton
interface RbxImageButton extends RbxGuiButton {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ImageButton";
	HoverImage: string;
	/** Specifies the asset id of the texture to display. [More info](http://wiki.roblox.com/index.php?title=API:Class/ImageButton/Image)  */
	Image: string;
	ImageColor3: Color3;
	ImageRectOffset: Vector2;
	ImageRectSize: Vector2;
	ImageTransparency: number;
	readonly IsLoaded: boolean;
	PressedImage: string;
	/** Specifies how an image should be displayed. See ScaleType for more info. */
	ScaleType: Enum.ScaleType;
	/** If ScaleType is set to Slice, this Rect is used to specify the central part of the image. Everything outside of this is considered to be the border. */
	SliceCenter: Rect;
	SliceScale: number;
	/** If ScaleType is set to Tile, this sets the size of the tile. */
	TileSize: UDim2;
}
type ImageButton = RbxImageButton & Indexable<RbxImageButton>;

// TextButton
interface RbxTextButton extends RbxGuiButton {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "TextButton";
	Font: Enum.Font;
	LineHeight: number;
	readonly LocalizedText: string;
	Text: string;
	readonly TextBounds: Vector2;
	TextColor3: Color3;
	readonly TextFits: boolean;
	TextScaled: boolean;
	TextSize: number;
	TextStrokeColor3: Color3;
	TextStrokeTransparency: number;
	TextTransparency: number;
	TextTruncate: Enum.TextTruncate;
	TextWrapped: boolean;
	TextXAlignment: Enum.TextXAlignment;
	TextYAlignment: Enum.TextYAlignment;
}
type TextButton = RbxTextButton & Indexable<RbxTextButton>;

// GuiLabel
interface RbxGuiLabel extends RbxGuiObject {
}
type GuiLabel = ImageLabel | TextLabel;

// ImageLabel
interface RbxImageLabel extends RbxGuiLabel {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ImageLabel";
	/** Specifies the id of the texture to display. [More info](http://wiki.roblox.com/index.php?title=API:Class/ImageLabel/Image) */
	Image: string;
	ImageColor3: Color3;
	ImageRectOffset: Vector2;
	ImageRectSize: Vector2;
	ImageTransparency: number;
	readonly IsLoaded: boolean;
	/** Specifies how an image should be displayed. See ScaleType for more info. */
	ScaleType: Enum.ScaleType;
	/** If ScaleType is set to Slice, this Rect is used to specify the central part of the image. Everything outside of this is considered to be the border. */
	SliceCenter: Rect;
	SliceScale: number;
	/** If ScaleType is set to Tile, this sets the size of the tile. */
	TileSize: UDim2;
}
type ImageLabel = RbxImageLabel & Indexable<RbxImageLabel>;

// TextLabel
interface RbxTextLabel extends RbxGuiLabel {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "TextLabel";
	Font: Enum.Font;
	LineHeight: number;
	readonly LocalizedText: string;
	Text: string;
	readonly TextBounds: Vector2;
	TextColor3: Color3;
	readonly TextFits: boolean;
	TextScaled: boolean;
	TextSize: number;
	TextStrokeColor3: Color3;
	TextStrokeTransparency: number;
	TextTransparency: number;
	TextTruncate: Enum.TextTruncate;
	TextWrapped: boolean;
	TextXAlignment: Enum.TextXAlignment;
	TextYAlignment: Enum.TextYAlignment;
}
type TextLabel = RbxTextLabel & Indexable<RbxTextLabel>;

// ScrollingFrame
interface RbxScrollingFrame extends RbxGuiObject {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ScrollingFrame";
	/** The size in pixels of the frame, without the scrollbars. */
	readonly AbsoluteWindowSize: Vector2;
	/** The "Down" image on the vertical scrollbar. Size of this is always ScrollBarThickness by ScrollBarThickness. This is also used as the "right" image on the horizontal scroll bar. */
	BottomImage: string;
	/** The absolute position the scroll frame is in respect to the canvas size. The minimum this can be set to is (0,0), while the max is the absolute canvas size - AbsoluteWindowSize. */
	CanvasPosition: Vector2;
	/** Determines the size of the area that is scrollable. The UDim2 is calculated using the parent gui's size, similar to the regular Size property on gui objects. */
	CanvasSize: UDim2;
	ElasticBehavior: Enum.ElasticBehavior;
	HorizontalScrollBarInset: Enum.ScrollBarInset;
	/** The "Middle" image on the vertical scrollbar. Size of this can vary in the y direction, but is always set at ScrollBarThickness in x direction. This is also used as the "mid" image on the horizontal scroll bar. */
	MidImage: string;
	ScrollBarImageColor3: Color3;
	ScrollBarImageTransparency: number;
	/** How thick the scroll bar appears. This applies to both the horizontal and vertical scroll bars. Can be set to 0 for no bars render. */
	ScrollBarThickness: number;
	ScrollingDirection: Enum.ScrollingDirection;
	/** Determines whether or not scrolling is allowed on this frame. If turned off, no scroll bars will be rendered. */
	ScrollingEnabled: boolean;
	/** The "Up" image on the vertical scrollbar. Size of this is always ScrollBarThickness by ScrollBarThickness. This is also used as the "left" image on the horizontal scroll bar. */
	TopImage: string;
	VerticalScrollBarInset: Enum.ScrollBarInset;
	VerticalScrollBarPosition: Enum.VerticalScrollBarPosition;
}
type ScrollingFrame = RbxScrollingFrame & Indexable<RbxScrollingFrame>;

// TextBox
interface RbxTextBox extends RbxGuiObject {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "TextBox";
	ClearTextOnFocus: boolean;
	CursorPosition: number;
	Font: Enum.Font;
	LineHeight: number;
	MultiLine: boolean;
	PlaceholderColor3: Color3;
	PlaceholderText: string;
	ShowNativeInput: boolean;
	Text: string;
	readonly TextBounds: Vector2;
	TextColor3: Color3;
	readonly TextFits: boolean;
	TextScaled: boolean;
	TextSize: number;
	TextStrokeColor3: Color3;
	TextStrokeTransparency: number;
	TextTransparency: number;
	TextTruncate: Enum.TextTruncate;
	TextWrapped: boolean;
	TextXAlignment: Enum.TextXAlignment;
	TextYAlignment: Enum.TextYAlignment;
	CaptureFocus(): void;
	IsFocused(): boolean;
	ReleaseFocus(submitted?: boolean): void;
	readonly FocusLost: RBXScriptSignal<(enterPressed: boolean, inputThatCausedFocusLoss: Instance) => void>;
	readonly Focused: RBXScriptSignal<() => void>;
}
type TextBox = RbxTextBox & Indexable<RbxTextBox>;

// ViewportFrame
interface RbxViewportFrame extends RbxGuiObject {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ViewportFrame";
	/** Current Camera of children objects */
	CurrentCamera?: Camera;
	/** The rendered image of the ViewportFrame will be mutiplied by this color */
	ImageColor3: Color3;
	/** A number value that specifies how transparent the rendered image of the ViewportFrame is */
	ImageTransparency: number;
}
type ViewportFrame = RbxViewportFrame & Indexable<RbxViewportFrame>;

// LayerCollector
interface RbxLayerCollector extends RbxGuiBase2d {
	Enabled: boolean;
	ResetOnSpawn: boolean;
	ZIndexBehavior: Enum.ZIndexBehavior;
}
type LayerCollector = BillboardGui | PluginGui | DerivesFromScreenGui | SurfaceGui;

// BillboardGui
interface RbxBillboardGui extends RbxLayerCollector {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "BillboardGui";
	/** If true, this GuiObject can fire mouse events and will pass them to any GuiObjects layered underneath, while false will do neither. */
	Active: boolean;
	/** If true, billboard gui does not get occluded by 3D objects, but always renders on the screen. */
	AlwaysOnTop: boolean;
	ClipsDescendants: boolean;
	/** A Vector3 (x,y,z) defined in studs that will offset the gui from the extents of the 3d object it is rendering from. */
	ExtentsOffset: Vector3;
	ExtentsOffsetWorldSpace: Vector3;
	/** Specifies the amount of influence lighting has on the billboard gui. A value of 0 is unlit, 1 is fully lit. Fractional values blend from unlit to lit. */
	LightInfluence: number;
	MaxDistance: number;
	/** A UDim2 value describing the size of the BillboardGui. More information on UDim2 is available [here](http://wiki.roblox.com/index.php/UDim2). Relative values are defined as one-to-one with studs. */
	Size: UDim2;
	/** A Vector2 (x,y) defined in studs that will offset the gui size from it's current size. */
	SizeOffset: Vector2;
	/** A Vector3 (x,y,z) defined in studs that will offset the gui from the centroid of the 3d object it is rendering from */
	StudsOffset: Vector3;
	StudsOffsetWorldSpace: Vector3;
}
type BillboardGui = RbxBillboardGui & Indexable<RbxBillboardGui>;

// PluginGui
interface RbxPluginGui extends RbxLayerCollector {
	Title: string;
	BindToClose(callback?: Function): void;
}
type PluginGui = DockWidgetPluginGui | QWidgetPluginGui;

// DockWidgetPluginGui
interface RbxDockWidgetPluginGui extends RbxPluginGui {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "DockWidgetPluginGui";
	readonly HostWidgetWasRestored: boolean;
}
type DockWidgetPluginGui = RbxDockWidgetPluginGui & Indexable<RbxDockWidgetPluginGui>;

// QWidgetPluginGui
interface RbxQWidgetPluginGui extends RbxPluginGui {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "QWidgetPluginGui";
}
type QWidgetPluginGui = RbxQWidgetPluginGui & Indexable<RbxQWidgetPluginGui>;

// DerivesFromScreenGui
interface RbxDerivesFromScreenGui extends RbxLayerCollector {
	DisplayOrder: number;
	IgnoreGuiInset: boolean;
}
interface RbxScreenGui extends RbxDerivesFromScreenGui {
	readonly ClassName: "ScreenGui";
}

type ScreenGui = RbxScreenGui & Indexable<RbxScreenGui>;
type DerivesFromScreenGui = ScreenGui | GuiMain;

// GuiMain
interface RbxGuiMain extends RbxDerivesFromScreenGui {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "GuiMain";
}
type GuiMain = RbxGuiMain & Indexable<RbxGuiMain>;

// SurfaceGui
interface RbxSurfaceGui extends RbxLayerCollector {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "SurfaceGui";
	/** If true, this GuiObject can fire mouse events and will pass them to any GuiObjects layered underneath, while false will do neither. */
	Active: boolean;
	AlwaysOnTop: boolean;
	CanvasSize: Vector2;
	ClipsDescendants: boolean;
	Face: Enum.NormalId;
	/** Specifies the amount of influence lighting has on the surface gui. A value of 0 is unlit, 1 is fully lit. Fractional values blend from unlit to lit. */
	LightInfluence: number;
	ToolPunchThroughDistance: number;
	ZOffset: number;
}
type SurfaceGui = RbxSurfaceGui & Indexable<RbxSurfaceGui>;

// GuiBase3d
interface RbxGuiBase3d extends RbxGuiBase {
	Color3: Color3;
	Transparency: number;
	Visible: boolean;
}
type GuiBase3d = FloorWire | PVAdornment | PartAdornment | SelectionLasso;

// FloorWire
interface RbxFloorWire extends RbxGuiBase3d {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "FloorWire";
	/** Controls how the decals are positioned along the wire. [More info](http://wiki.roblox.com/index.php/CycleOffset) */
	CycleOffset: number;
	/** The object the FloorWire 'emits' from */
	From?: BasePart;
	/** The space between two textures on the wire. Note: studs are relative depending on how far the camera is from the FloorWire. */
	StudsBetweenTextures: number;
	/** The image we use to render the textures that flow from beginning to end of the FloorWire. */
	Texture: string;
	/** The size in studs of the Texture we use to flow from one object to the next. */
	TextureSize: Vector2;
	/** The object the FloorWire 'emits' to */
	To?: BasePart;
	/** The rate of travel that the textures flow along the wire. */
	Velocity: number;
	/** How thick the wire is. */
	WireRadius: number;
}
type FloorWire = RbxFloorWire & Indexable<RbxFloorWire>;

// PVAdornment
interface RbxPVAdornment extends RbxGuiBase3d {
	Adornee?: PVInstance;
}
type PVAdornment = HandleAdornment | ParabolaAdornment | SelectionBox | SelectionSphere;

// HandleAdornment
interface RbxHandleAdornment extends RbxPVAdornment {
	AlwaysOnTop: boolean;
	CFrame: CFrame;
	SizeRelativeOffset: Vector3;
	ZIndex: number;
	readonly MouseButton1Down: RBXScriptSignal<() => void>;
	readonly MouseButton1Up: RBXScriptSignal<() => void>;
	readonly MouseEnter: RBXScriptSignal<() => void>;
	readonly MouseLeave: RBXScriptSignal<() => void>;
}
type HandleAdornment = BoxHandleAdornment | ConeHandleAdornment | CylinderHandleAdornment | ImageHandleAdornment | LineHandleAdornment | SphereHandleAdornment;

// BoxHandleAdornment
interface RbxBoxHandleAdornment extends RbxHandleAdornment {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "BoxHandleAdornment";
	Size: Vector3;
}
type BoxHandleAdornment = RbxBoxHandleAdornment & Indexable<RbxBoxHandleAdornment>;

// ConeHandleAdornment
interface RbxConeHandleAdornment extends RbxHandleAdornment {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ConeHandleAdornment";
	Height: number;
	Radius: number;
}
type ConeHandleAdornment = RbxConeHandleAdornment & Indexable<RbxConeHandleAdornment>;

// CylinderHandleAdornment
interface RbxCylinderHandleAdornment extends RbxHandleAdornment {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "CylinderHandleAdornment";
	Height: number;
	Radius: number;
}
type CylinderHandleAdornment = RbxCylinderHandleAdornment & Indexable<RbxCylinderHandleAdornment>;

// ImageHandleAdornment
interface RbxImageHandleAdornment extends RbxHandleAdornment {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ImageHandleAdornment";
	Image: string;
	Size: Vector2;
}
type ImageHandleAdornment = RbxImageHandleAdornment & Indexable<RbxImageHandleAdornment>;

// LineHandleAdornment
interface RbxLineHandleAdornment extends RbxHandleAdornment {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "LineHandleAdornment";
	Length: number;
	Thickness: number;
}
type LineHandleAdornment = RbxLineHandleAdornment & Indexable<RbxLineHandleAdornment>;

// SphereHandleAdornment
interface RbxSphereHandleAdornment extends RbxHandleAdornment {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "SphereHandleAdornment";
	Radius: number;
}
type SphereHandleAdornment = RbxSphereHandleAdornment & Indexable<RbxSphereHandleAdornment>;

// ParabolaAdornment
interface RbxParabolaAdornment extends RbxPVAdornment {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ParabolaAdornment";
}
type ParabolaAdornment = RbxParabolaAdornment & Indexable<RbxParabolaAdornment>;

// SelectionBox
interface RbxSelectionBox extends RbxPVAdornment {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "SelectionBox";
	LineThickness: number;
	SurfaceColor3: Color3;
	SurfaceTransparency: number;
}
type SelectionBox = RbxSelectionBox & Indexable<RbxSelectionBox>;

// SelectionSphere
interface RbxSelectionSphere extends RbxPVAdornment {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "SelectionSphere";
	SurfaceColor3: Color3;
	SurfaceTransparency: number;
}
type SelectionSphere = RbxSelectionSphere & Indexable<RbxSelectionSphere>;

// PartAdornment
interface RbxPartAdornment extends RbxGuiBase3d {
	Adornee?: BasePart;
}
type PartAdornment = HandlesBase | SurfaceSelection;

// HandlesBase
interface RbxHandlesBase extends RbxPartAdornment {
}
type HandlesBase = ArcHandles | Handles;

// ArcHandles
interface RbxArcHandles extends RbxHandlesBase {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ArcHandles";
	Axes: Axes;
	readonly MouseButton1Down: RBXScriptSignal<(axis: Enum.Axis) => void>;
	readonly MouseButton1Up: RBXScriptSignal<(axis: Enum.Axis) => void>;
	readonly MouseDrag: RBXScriptSignal<(axis: Enum.Axis, relativeAngle: number, deltaRadius: number) => void>;
	readonly MouseEnter: RBXScriptSignal<(axis: Enum.Axis) => void>;
	readonly MouseLeave: RBXScriptSignal<(axis: Enum.Axis) => void>;
}
type ArcHandles = RbxArcHandles & Indexable<RbxArcHandles>;

// Handles
interface RbxHandles extends RbxHandlesBase {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Handles";
	Faces: Faces;
	Style: Enum.HandlesStyle;
	readonly MouseButton1Down: RBXScriptSignal<(face: Enum.NormalId) => void>;
	readonly MouseButton1Up: RBXScriptSignal<(face: Enum.NormalId) => void>;
	readonly MouseDrag: RBXScriptSignal<(face: Enum.NormalId, distance: number) => void>;
	readonly MouseEnter: RBXScriptSignal<(face: Enum.NormalId) => void>;
	readonly MouseLeave: RBXScriptSignal<(face: Enum.NormalId) => void>;
}
type Handles = RbxHandles & Indexable<RbxHandles>;

// SurfaceSelection
interface RbxSurfaceSelection extends RbxPartAdornment {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "SurfaceSelection";
	TargetSurface: Enum.NormalId;
}
type SurfaceSelection = RbxSurfaceSelection & Indexable<RbxSurfaceSelection>;

// SelectionLasso
interface RbxSelectionLasso extends RbxGuiBase3d {
	Humanoid?: Humanoid;
}
type SelectionLasso = SelectionPartLasso | SelectionPointLasso;

// SelectionPartLasso
interface RbxSelectionPartLasso extends RbxSelectionLasso {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "SelectionPartLasso";
	Part?: BasePart;
}
type SelectionPartLasso = RbxSelectionPartLasso & Indexable<RbxSelectionPartLasso>;

// SelectionPointLasso
interface RbxSelectionPointLasso extends RbxSelectionLasso {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "SelectionPointLasso";
	Point: Vector3;
}
type SelectionPointLasso = RbxSelectionPointLasso & Indexable<RbxSelectionPointLasso>;

// GuiService
interface RbxGuiService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "GuiService";
	AutoSelectGuiEnabled: boolean;
	CoreGuiNavigationEnabled: boolean;
	GuiNavigationEnabled: boolean;
	readonly MenuIsOpen: boolean;
	SelectedObject?: GuiObject;
	IsTenFootInterface(): boolean;
	RemoveSelectionGroup(selectionName: string): void;
	readonly MenuClosed: RBXScriptSignal<() => void>;
	readonly MenuOpened: RBXScriptSignal<() => void>;
}
type GuiService = RbxGuiService & Indexable<RbxGuiService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "GuiService"): GuiService;
}

// GuidRegistryService
interface RbxGuidRegistryService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "GuidRegistryService";
}
type GuidRegistryService = RbxGuidRegistryService & Indexable<RbxGuidRegistryService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "GuidRegistryService"): GuidRegistryService;
}

// HapticService
interface RbxHapticService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "HapticService";
	IsMotorSupported(inputType: Enum.UserInputType, vibrationMotor: Enum.VibrationMotor): boolean;
	IsVibrationSupported(inputType: Enum.UserInputType): boolean;
}
type HapticService = RbxHapticService & Indexable<RbxHapticService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "HapticService"): HapticService;
}

// Hopper
interface RbxHopper extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Hopper";
}
type Hopper = RbxHopper & Indexable<RbxHopper>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "Hopper"): Hopper;
}

// HttpRbxApiService
interface RbxHttpRbxApiService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "HttpRbxApiService";
}
type HttpRbxApiService = RbxHttpRbxApiService & Indexable<RbxHttpRbxApiService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "HttpRbxApiService"): HttpRbxApiService;
}

// HttpRequest
interface RbxHttpRequest extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "HttpRequest";
}
type HttpRequest = RbxHttpRequest & Indexable<RbxHttpRequest>;

// HttpService
interface RbxHttpService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "HttpService";
	GenerateGUID(wrapInCurlyBraces?: boolean): string;
	JSONDecode(input: string): unknown;
	JSONEncode(input?: any): string;
	UrlEncode(input: string): string;
}
type HttpService = RbxHttpService & Indexable<RbxHttpService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "HttpService"): HttpService;
}

// Humanoid
interface RbxHumanoid extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Humanoid";
	AutoJumpEnabled: boolean;
	AutoRotate: boolean;
	AutomaticScalingEnabled: boolean;
	BreakJointsOnDeath: boolean;
	CameraOffset: Vector3;
	DisplayDistanceType: Enum.HumanoidDisplayDistanceType;
	readonly FloorMaterial: Enum.Material;
	/** How many hit points the Humanoid has.  When this number reaches 0 or goes below 0, the Humanoid's character falls apart and will respawn. */
	Health: number;
	HealthDisplayDistance: number;
	HealthDisplayType: Enum.HumanoidHealthDisplayType;
	HipHeight: number;
	Jump: boolean;
	JumpHeight: number;
	JumpPower: number;
	/** The maximum number of hit points a Humanoid's health can reach.  If the Humanoid's health is set over this amount, the health gets set to this value. */
	MaxHealth: number;
	MaxSlopeAngle: number;
	readonly MoveDirection: Vector3;
	NameDisplayDistance: number;
	/** Sets how to display other humanoid names to this humanoid's player. [More info](http://wiki.roblox.com/index.php/NameOcclusion) */
	NameOcclusion: Enum.NameOcclusion;
	PlatformStand: boolean;
	RigType: Enum.HumanoidRigType;
	readonly RootPart?: BasePart;
	readonly SeatPart?: BasePart;
	Sit: boolean;
	/** The location that the Humanoid is trying to walk to. */
	TargetPoint: Vector3;
	UseJumpPower: boolean;
	WalkSpeed: number;
	WalkToPart?: BasePart;
	WalkToPoint: Vector3;
	BuildRigFromAttachments(): void;
	ChangeState(state?: Enum.HumanoidStateType): void;
	GetState(): Enum.HumanoidStateType;
	GetStateEnabled(state: Enum.HumanoidStateType): boolean;
	Move(moveDirection: Vector3, relativeToCamera?: boolean): void;
	RemoveAccessories(): void;
	SetStateEnabled(state: Enum.HumanoidStateType, enabled: boolean): void;
	/** Decreases health by the amount.  Use this instead of changing health directly to make sure weapons are filtered for things such as ForceField(s). */
	TakeDamage(amount: number): void;
	/** Takes any active gear/tools that the Humanoid is using and puts them into the backpack.  This function only works on Humanoids with a corresponding Player. */
	UnequipTools(): void;
	readonly Climbing: RBXScriptSignal<(speed: number) => void>;
	readonly Died: RBXScriptSignal<() => void>;
	readonly FallingDown: RBXScriptSignal<(active: boolean) => void>;
	readonly FreeFalling: RBXScriptSignal<(active: boolean) => void>;
	readonly GettingUp: RBXScriptSignal<(active: boolean) => void>;
	readonly HealthChanged: RBXScriptSignal<(health: number) => void>;
	readonly Jumping: RBXScriptSignal<(active: boolean) => void>;
	readonly MoveToFinished: RBXScriptSignal<(reached: boolean) => void>;
	readonly PlatformStanding: RBXScriptSignal<(active: boolean) => void>;
	readonly Ragdoll: RBXScriptSignal<(active: boolean) => void>;
	readonly Running: RBXScriptSignal<(speed: number) => void>;
	readonly StateChanged: RBXScriptSignal<(oldValue: Enum.HumanoidStateType, newValue: Enum.HumanoidStateType) => void>;
	readonly StateEnabledChanged: RBXScriptSignal<(state: Enum.HumanoidStateType, isEnabled: boolean) => void>;
	readonly Strafing: RBXScriptSignal<(active: boolean) => void>;
	readonly Swimming: RBXScriptSignal<(speed: number) => void>;
}
type Humanoid = RbxHumanoid & Indexable<RbxHumanoid>;

// HumanoidDescription
interface RbxHumanoidDescription extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "HumanoidDescription";
	BackAccessory: string;
	BodyTypeScale: number;
	ClimbAnimation: number;
	DepthScale: number;
	Face: number;
	FaceAccessory: string;
	FallAnimation: number;
	FrontAccessory: string;
	GraphicTShirt: number;
	HairAccessory: string;
	HatAccessory: string;
	Head: number;
	HeadColor: Color3;
	HeadScale: number;
	HeightScale: number;
	IdleAnimation: number;
	JumpAnimation: number;
	LeftArm: number;
	LeftArmColor: Color3;
	LeftLeg: number;
	LeftLegColor: Color3;
	NeckAccessory: string;
	Pants: number;
	ProportionScale: number;
	RightArm: number;
	RightArmColor: Color3;
	RightLeg: number;
	RightLegColor: Color3;
	RunAnimation: number;
	Shirt: number;
	ShouldersAccessory: string;
	SwimAnimation: number;
	Torso: number;
	TorsoColor: Color3;
	WaistAccessory: string;
	WalkAnimation: number;
	WidthScale: number;
}
type HumanoidDescription = RbxHumanoidDescription & Indexable<RbxHumanoidDescription>;

// InputObject
interface RbxInputObject extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "InputObject";
	Delta: Vector3;
	/** An enum that describes what kind of input is being pressed. For types of input like Keyboard, this describes what key was pressed. For input like mousebutton, this provides no additional information. */
	KeyCode: Enum.KeyCode;
	/** A Vector3 value that describes a positional value of this input. For mouse and touch input, this is the screen position of the mouse/touch, described in the x and y components. For mouse wheel input, the z component describes whether the wheel was moved forward or backward. */
	Position: Vector3;
	/** An enum that describes what state of a particular input (touch began, touch moved, touch ended, etc.). See Enum.UserInputState for more info. */
	UserInputState: Enum.UserInputState;
	/** An enum that describes what kind of input this object is describing (mousebutton, touch, etc.).  See Enum.UserInputType for more info. */
	UserInputType: Enum.UserInputType;
}
type InputObject = RbxInputObject & Indexable<RbxInputObject>;

// InsertService
interface RbxInsertService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "InsertService";
	GetLatestAssetVersionAsync(assetId: number): number;
}
type InsertService = RbxInsertService & Indexable<RbxInsertService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "InsertService"): InsertService;
}

// JointInstance
interface RbxJointInstance extends RbxInstance {
	/** Read-only boolean, true if the joint is active in world. Rigid joints may be inactive if they are redundant or form cycles. */
	readonly Active: boolean;
	C0: CFrame;
	C1: CFrame;
}
type JointInstance = DynamicRotate | Glue | ManualSurfaceJointInstance | DerivesFromMotor | Rotate | Snap | VelocityMotor | Weld;

// DynamicRotate
interface RbxDynamicRotate extends RbxJointInstance {
	BaseAngle: number;
}
type DynamicRotate = RotateP | RotateV;

// RotateP
interface RbxRotateP extends RbxDynamicRotate {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "RotateP";
}
type RotateP = RbxRotateP & Indexable<RbxRotateP>;

// RotateV
interface RbxRotateV extends RbxDynamicRotate {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "RotateV";
}
type RotateV = RbxRotateV & Indexable<RbxRotateV>;

// Glue
interface RbxGlue extends RbxJointInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Glue";
	F0: Vector3;
	F1: Vector3;
	F2: Vector3;
	F3: Vector3;
}
type Glue = RbxGlue & Indexable<RbxGlue>;

// ManualSurfaceJointInstance
interface RbxManualSurfaceJointInstance extends RbxJointInstance {
}
type ManualSurfaceJointInstance = ManualGlue | ManualWeld;

// ManualGlue
interface RbxManualGlue extends RbxManualSurfaceJointInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ManualGlue";
}
type ManualGlue = RbxManualGlue & Indexable<RbxManualGlue>;

// ManualWeld
interface RbxManualWeld extends RbxManualSurfaceJointInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ManualWeld";
}
type ManualWeld = RbxManualWeld & Indexable<RbxManualWeld>;

// DerivesFromMotor
interface RbxDerivesFromMotor extends RbxJointInstance {
	CurrentAngle: number;
	DesiredAngle: number;
	MaxVelocity: number;
	SetDesiredAngle(value: number): void;
}
interface RbxMotor extends RbxDerivesFromMotor {
	readonly ClassName: "Motor";
}

type Motor = RbxMotor & Indexable<RbxMotor>;
type DerivesFromMotor = Motor | Motor6D;

// Motor6D
interface RbxMotor6D extends RbxDerivesFromMotor {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Motor6D";
	Transform: CFrame;
}
type Motor6D = RbxMotor6D & Indexable<RbxMotor6D>;

// Rotate
interface RbxRotate extends RbxJointInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Rotate";
}
type Rotate = RbxRotate & Indexable<RbxRotate>;

// Snap
interface RbxSnap extends RbxJointInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Snap";
}
type Snap = RbxSnap & Indexable<RbxSnap>;

// VelocityMotor
interface RbxVelocityMotor extends RbxJointInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "VelocityMotor";
	CurrentAngle: number;
	DesiredAngle: number;
	Hole?: Hole;
	MaxVelocity: number;
}
type VelocityMotor = RbxVelocityMotor & Indexable<RbxVelocityMotor>;

// Weld
interface RbxWeld extends RbxJointInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Weld";
}
type Weld = RbxWeld & Indexable<RbxWeld>;

// JointsService
interface RbxJointsService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "JointsService";
	ClearJoinAfterMoveJoints(): void;
	CreateJoinAfterMoveJoints(): void;
	SetJoinAfterMoveInstance(joinInstance: Instance): void;
	SetJoinAfterMoveTarget(joinTarget: Instance): void;
	ShowPermissibleJoints(): void;
}
type JointsService = RbxJointsService & Indexable<RbxJointsService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "JointsService"): JointsService;
}

// KeyboardService
interface RbxKeyboardService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "KeyboardService";
}
type KeyboardService = RbxKeyboardService & Indexable<RbxKeyboardService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "KeyboardService"): KeyboardService;
}

// Keyframe
interface RbxKeyframe extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Keyframe";
	Time: number;
	AddMarker(marker: Instance): void;
	GetMarkers(): Array<Instance>;
	RemoveMarker(marker: Instance): void;
}
type Keyframe = RbxKeyframe & Indexable<RbxKeyframe>;

// KeyframeMarker
interface RbxKeyframeMarker extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "KeyframeMarker";
	Value: string;
}
type KeyframeMarker = RbxKeyframeMarker & Indexable<RbxKeyframeMarker>;

// KeyframeSequence
interface RbxKeyframeSequence extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "KeyframeSequence";
	Loop: boolean;
	Priority: Enum.AnimationPriority;
}
type KeyframeSequence = RbxKeyframeSequence & Indexable<RbxKeyframeSequence>;

// KeyframeSequenceProvider
interface RbxKeyframeSequenceProvider extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "KeyframeSequenceProvider";
}
type KeyframeSequenceProvider = RbxKeyframeSequenceProvider & Indexable<RbxKeyframeSequenceProvider>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "KeyframeSequenceProvider"): KeyframeSequenceProvider;
}

// Light
interface RbxLight extends RbxInstance {
	Brightness: number;
	Color: Color3;
	Enabled: boolean;
	Shadows: boolean;
}
type Light = PointLight | SpotLight | SurfaceLight;

// PointLight
interface RbxPointLight extends RbxLight {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "PointLight";
	Range: number;
}
type PointLight = RbxPointLight & Indexable<RbxPointLight>;

// SpotLight
interface RbxSpotLight extends RbxLight {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "SpotLight";
	Angle: number;
	Face: Enum.NormalId;
	Range: number;
}
type SpotLight = RbxSpotLight & Indexable<RbxSpotLight>;

// SurfaceLight
interface RbxSurfaceLight extends RbxLight {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "SurfaceLight";
	Angle: number;
	Face: Enum.NormalId;
	Range: number;
}
type SurfaceLight = RbxSurfaceLight & Indexable<RbxSurfaceLight>;

// Lighting
interface RbxLighting extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Lighting";
	/** The hue of the global lighting.  Changing this changes the color tint of all objects in the Workspace. */
	Ambient: Color3;
	/** How much global light each Part in the Workspace receives. Standard range is 0 to 2 (0 being little light), but can be increased all the way to 10 (colors start to be appear very different at this value). */
	Brightness: number;
	ClockTime: number;
	/** The hue of global lighting on the bottom surfaces of an object. */
	ColorShift_Bottom: Color3;
	/** The hue of global lighting on the top surfaces of an object. */
	ColorShift_Top: Color3;
	/** Exposure compensation amount. Applies a bias to the exposure level prior to the tonemap step. +1 indicates twice as much exposure and -1 means half as much exposure. */
	ExposureCompensation: number;
	/** A Color3 value that changes the hue of distance fog. */
	FogColor: Color3;
	/** The distance at which fog completely blocks your vision. This distance is relative to the camera position. Units are in studs */
	FogEnd: number;
	/** The distance at which the fog gradient begins. This distance is relative to the camera position. Units are in studs. */
	FogStart: number;
	/** The latitude position the level is placed at.  This affects sun position. [More info](http://wiki.roblox.com/index.php/GeographicLatitude) */
	GeographicLatitude: number;
	/** Flag enabling shadows from sun and moon in the place */
	GlobalShadows: boolean;
	/** Effective ambient value for outdoors, effectively shadow color outdoors (requires GlobalShadows enabled) */
	OutdoorAmbient: Color3;
	/** Flag enabling or disabling outlines on parts and terrain */
	Outlines: boolean;
	/** A string that represent the current time of day. Time is in 24-hour clock format "XX::YY:ZZ", where X is hour, Y is minute, and Z is seconds. */
	TimeOfDay: string;
	/** The number of minutes that the current time is past midnight.  If currently at midnight, returns 0.  Will return decimal values if not at an exact minute. */
	GetMinutesAfterMidnight(): number;
	/** Returns the lookVector (Vector3) of the moon. If this lookVector was used in a CFrame, the Part would face the moon. */
	GetMoonDirection(): Vector3;
	/** Currently always returns 0.75. MoonPhase cannot be edited. */
	GetMoonPhase(): number;
	/** Returns the lookVector (Vector3) of the sun. If this lookVector was used in a CFrame, the Part would face the sun. */
	GetSunDirection(): Vector3;
	/** Sets the time to be a certain number of minutes after midnight.  This works with integer and decimal values. */
	SetMinutesAfterMidnight(minutes: number): void;
	/** Fired whenever a property of Lighting is changed, or a skybox is added or removed. Skyboxes are of type 'Sky' and should be parented directly to lighting. */
	readonly LightingChanged: RBXScriptSignal<(skyboxChanged: boolean) => void>;
}
type Lighting = RbxLighting & Indexable<RbxLighting>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "Lighting"): Lighting;
}

// LocalStorageService
interface RbxLocalStorageService extends RbxInstance {
}
type LocalStorageService = AppStorageService | UserStorageService;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "LocalStorageService"): LocalStorageService;
}

// AppStorageService
interface RbxAppStorageService extends RbxLocalStorageService {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "AppStorageService";
}
type AppStorageService = RbxAppStorageService & Indexable<RbxAppStorageService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "AppStorageService"): AppStorageService;
}

// UserStorageService
interface RbxUserStorageService extends RbxLocalStorageService {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "UserStorageService";
}
type UserStorageService = RbxUserStorageService & Indexable<RbxUserStorageService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "UserStorageService"): UserStorageService;
}

// LocalizationService
interface RbxLocalizationService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "LocalizationService";
	readonly RobloxLocaleId: string;
	readonly SystemLocaleId: string;
	GetCorescriptLocalizations(): Array<Instance>;
	GetTableEntries(instance?: Instance): unknown;
	GetTranslatorForLocaleAsync(locale: string): Instance | undefined;
	GetTranslatorForPlayerAsync(player: Instance): Instance | undefined;
}
type LocalizationService = RbxLocalizationService & Indexable<RbxLocalizationService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "LocalizationService"): LocalizationService;
}

// LocalizationTable
interface RbxLocalizationTable extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "LocalizationTable";
	SourceLocaleId: string;
	RemoveEntry(key: string, source: string, context: string): void;
	RemoveEntryValue(key: string, source: string, context: string, localeId: string): void;
	RemoveTargetLocale(localeId: string): void;
	SetEntries(entries?: any): void;
	SetEntryContext(key: string, source: string, context: string, newContext: string): void;
	SetEntryExample(key: string, source: string, context: string, example: string): void;
	SetEntryKey(key: string, source: string, context: string, newKey: string): void;
	SetEntrySource(key: string, source: string, context: string, newSource: string): void;
	SetEntryValue(key: string, source: string, context: string, localeId: string, text: string): void;
}
type LocalizationTable = RbxLocalizationTable & Indexable<RbxLocalizationTable>;

// LogService
interface RbxLogService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "LogService";
	readonly MessageOut: RBXScriptSignal<(message: string, messageType: Enum.MessageType) => void>;
}
type LogService = RbxLogService & Indexable<RbxLogService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "LogService"): LogService;
}

// LoginService
interface RbxLoginService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "LoginService";
}
type LoginService = RbxLoginService & Indexable<RbxLoginService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "LoginService"): LoginService;
}

// LuaSettings
interface RbxLuaSettings extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "LuaSettings";
	AreScriptStartsReported: boolean;
	DefaultWaitTime: number;
	GcFrequency: number;
	GcLimit: number;
	GcPause: number;
	GcStepMul: number;
	WaitingThreadsBudget: number;
}
type LuaSettings = RbxLuaSettings & Indexable<RbxLuaSettings>;

// LuaSourceContainer
interface RbxLuaSourceContainer extends RbxInstance {
}
type LuaSourceContainer = BaseScript | ModuleScript;

// BaseScript
interface RbxBaseScript extends RbxLuaSourceContainer {
	Disabled: boolean;
	LinkedSource: string;
}
type BaseScript = CoreScript | DerivesFromScript;

// CoreScript
interface RbxCoreScript extends RbxBaseScript {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "CoreScript";
}
type CoreScript = RbxCoreScript & Indexable<RbxCoreScript>;

// DerivesFromScript
interface RbxDerivesFromScript extends RbxBaseScript {
}
interface RbxScript extends RbxDerivesFromScript {
	readonly ClassName: "Script";
}

type Script = RbxScript & Indexable<RbxScript>;
type DerivesFromScript = Script | LocalScript;

// LocalScript
interface RbxLocalScript extends RbxDerivesFromScript {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "LocalScript";
}
type LocalScript = RbxLocalScript & Indexable<RbxLocalScript>;

// ModuleScript
interface RbxModuleScript extends RbxLuaSourceContainer {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ModuleScript";
	LinkedSource: string;
}
type ModuleScript = RbxModuleScript & Indexable<RbxModuleScript>;

// LuaWebService
interface RbxLuaWebService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "LuaWebService";
}
type LuaWebService = RbxLuaWebService & Indexable<RbxLuaWebService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "LuaWebService"): LuaWebService;
}

// MarketplaceService
interface RbxMarketplaceService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "MarketplaceService";
	GetDeveloperProductsAsync(): Instance | undefined;
	UserOwnsGamePassAsync(userId: number, gamePassId: number): boolean;
}
type MarketplaceService = RbxMarketplaceService & Indexable<RbxMarketplaceService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "MarketplaceService"): MarketplaceService;
}

// DerivesFromMessage
interface RbxDerivesFromMessage extends RbxInstance {
	Text: string;
}
interface RbxMessage extends RbxDerivesFromMessage {
	readonly ClassName: "Message";
}

type Message = RbxMessage & Indexable<RbxMessage>;
type DerivesFromMessage = Message | Hint;

// Hint
interface RbxHint extends RbxDerivesFromMessage {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Hint";
}
type Hint = RbxHint & Indexable<RbxHint>;

// MessagingService
interface RbxMessagingService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "MessagingService";
	PublishAsync(topic: string, message?: any): void;
	SubscribeAsync(topic: string, callback: Function): RBXScriptConnection;
}
type MessagingService = RbxMessagingService & Indexable<RbxMessagingService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "MessagingService"): MessagingService;
}

// Mouse
interface RbxMouse extends RbxInstance {
	/** The CoordinateFrame of where the Mouse ray is currently hitting a 3D object in the Workspace.  If the mouse is not over any 3D objects in the Workspace, this property is nil. */
	readonly Hit: CFrame;
	/** The current Texture of the Mouse Icon. Stored as a string, for more information on how to format the string [go here](http://wiki.roblox.com/index.php/Content) */
	Icon: string;
	/** The CoordinateFrame of where the Mouse is when the mouse is not clicking. */
	readonly Origin: CFrame;
	/** The Part the mouse is currently over. If the mouse is not currently over any object (on the skybox, for example) this property is nil. */
	readonly Target?: BasePart;
	/** A Part or Model that the Mouse will ignore when trying to find the Target, TargetSurface and Hit. */
	TargetFilter?: Instance;
	/** The NormalId (Top, Left, Down, etc.) of the face of the part the Mouse is currently over. */
	readonly TargetSurface: Enum.NormalId;
	/** The Unit Ray from where the mouse is (Origin) to the current Mouse.Target. */
	readonly UnitRay: Ray;
	/** The viewport's (game window) width in pixels. */
	readonly ViewSizeX: number;
	/** The viewport's (game window) height in pixels. */
	readonly ViewSizeY: number;
	/** The absolute pixel position of the Mouse along the x-axis of the viewport (game window). Values start at 0 on the left hand side of the screen and increase to the right. */
	readonly X: number;
	/** The absolute pixel position of the Mouse along the y-axis of the viewport (game window). Values start at 0 on the top of the screen and increase to the bottom. */
	readonly Y: number;
	/** Fired when the first button (usually the left, but could be another) on the mouse is depressed. */
	readonly Button1Down: RBXScriptSignal<() => void>;
	/** Fired when the first button (usually the left, but could be another) on the mouse is release. */
	readonly Button1Up: RBXScriptSignal<() => void>;
	/** This event is currently non-operational. */
	readonly Button2Down: RBXScriptSignal<() => void>;
	/** This event is currently non-operational. */
	readonly Button2Up: RBXScriptSignal<() => void>;
	/** Fired constantly when the mouse is not firing any other event (i.e. the mouse isn't moving, nor any buttons being pressed or depressed). */
	readonly Idle: RBXScriptSignal<() => void>;
	/** Fired when the mouse X or Y member changes. */
	readonly Move: RBXScriptSignal<() => void>;
	/** This event is currently non-operational. */
	readonly WheelBackward: RBXScriptSignal<() => void>;
	/** This event is currently non-operational. */
	readonly WheelForward: RBXScriptSignal<() => void>;
}
type Mouse = PlayerMouse | PluginMouse;

// PlayerMouse
interface RbxPlayerMouse extends RbxMouse {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "PlayerMouse";
}
type PlayerMouse = RbxPlayerMouse & Indexable<RbxPlayerMouse>;

// PluginMouse
interface RbxPluginMouse extends RbxMouse {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "PluginMouse";
}
type PluginMouse = RbxPluginMouse & Indexable<RbxPluginMouse>;

// MouseService
interface RbxMouseService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "MouseService";
}
type MouseService = RbxMouseService & Indexable<RbxMouseService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "MouseService"): MouseService;
}

// NetworkMarker
interface RbxNetworkMarker extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "NetworkMarker";
	readonly Received: RBXScriptSignal<() => void>;
}
type NetworkMarker = RbxNetworkMarker & Indexable<RbxNetworkMarker>;

// NetworkPeer
interface RbxNetworkPeer extends RbxInstance {
}
type NetworkPeer = NetworkClient | NetworkServer;

// NetworkClient
interface RbxNetworkClient extends RbxNetworkPeer {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "NetworkClient";
	Ticket: string;
	readonly ConnectionAccepted: RBXScriptSignal<(peer: string, replicator: Instance) => void>;
	readonly ConnectionFailed: RBXScriptSignal<(peer: string, code: number, reason: string) => void>;
	readonly ConnectionRejected: RBXScriptSignal<(peer: string) => void>;
}
type NetworkClient = RbxNetworkClient & Indexable<RbxNetworkClient>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "NetworkClient"): NetworkClient;
}

// NetworkServer
interface RbxNetworkServer extends RbxNetworkPeer {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "NetworkServer";
	readonly Port: number;
}
type NetworkServer = RbxNetworkServer & Indexable<RbxNetworkServer>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "NetworkServer"): NetworkServer;
}

// NetworkReplicator
interface RbxNetworkReplicator extends RbxInstance {
	GetPlayer(): Instance | undefined;
}
type NetworkReplicator = ClientReplicator | ServerReplicator;

// ClientReplicator
interface RbxClientReplicator extends RbxNetworkReplicator {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ClientReplicator";
}
type ClientReplicator = RbxClientReplicator & Indexable<RbxClientReplicator>;

// ServerReplicator
interface RbxServerReplicator extends RbxNetworkReplicator {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ServerReplicator";
}
type ServerReplicator = RbxServerReplicator & Indexable<RbxServerReplicator>;

// NetworkSettings
interface RbxNetworkSettings extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "NetworkSettings";
	ArePhysicsRejectionsReported: boolean;
	ClientPhysicsSendRate: number;
	DataGCRate: number;
	DataMtuAdjust: number;
	DataSendPriority: Enum.PacketPriority;
	DataSendRate: number;
	IncommingReplicationLag: number;
	IsQueueErrorComputed: boolean;
	NetworkOwnerRate: number;
	PhysicsMtuAdjust: number;
	PhysicsSendPriority: Enum.PacketPriority;
	PhysicsSendRate: number;
	PreferredClientPort: number;
	PrintBits: boolean;
	PrintEvents: boolean;
	PrintFilters: boolean;
	PrintInstances: boolean;
	PrintPhysicsErrors: boolean;
	PrintProperties: boolean;
	PrintSplitMessage: boolean;
	PrintStreamInstanceQuota: boolean;
	PrintTouches: boolean;
	ProxyEnabled: boolean;
	ProxyURL: string;
	ReceiveRate: number;
	RenderStreamedRegions: boolean;
	ShowActiveAnimationAsset: boolean;
	TouchSendRate: number;
	TrackDataTypes: boolean;
	TrackPhysicsDetails: boolean;
	UsePhysicsPacketCache: boolean;
}
type NetworkSettings = RbxNetworkSettings & Indexable<RbxNetworkSettings>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "NetworkSettings"): NetworkSettings;
}

// NotificationService
interface RbxNotificationService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "NotificationService";
}
type NotificationService = RbxNotificationService & Indexable<RbxNotificationService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "NotificationService"): NotificationService;
}

// PVInstance
interface RbxPVInstance extends RbxInstance {
}
type PVInstance = BasePart | DerivesFromModel;

// BasePart
interface RbxBasePart extends RbxPVInstance {
	/** Determines whether or not physics acts upon the Part.  If true, part stays 'Anchored' in space, not moving regardless of any collision/forces acting upon it.  If false, physics works normally on the part. */
	Anchored: boolean;
	BackParamA: number;
	BackParamB: number;
	BackSurface: Enum.SurfaceType;
	BackSurfaceInput: Enum.InputType;
	BottomParamA: number;
	BottomParamB: number;
	BottomSurface: Enum.SurfaceType;
	BottomSurfaceInput: Enum.InputType;
	BrickColor: BrickColor;
	/** Contains information regarding the Part's position and a matrix that defines the Part's rotation.  Can read/write. [More info](http://wiki.roblox.com/index.php/Cframe) */
	CFrame: CFrame;
	/** Determines whether physical interactions with other Parts are respected.  If true, will collide and react with physics to other Parts.  If false, other parts will pass thru instead of colliding */
	CanCollide: boolean;
	readonly CenterOfMass: Vector3;
	CollisionGroupId: number;
	/** Color3 of the part. */
	Color: Color3;
	CustomPhysicalProperties: PhysicalProperties;
	FrontParamA: number;
	FrontParamB: number;
	FrontSurface: Enum.SurfaceType;
	FrontSurfaceInput: Enum.InputType;
	LeftParamA: number;
	LeftParamB: number;
	LeftSurface: Enum.SurfaceType;
	LeftSurfaceInput: Enum.InputType;
	LocalTransparencyModifier: number;
	/** Determines whether building tools (in-game and studio) can manipulate this Part.  If true, no editing allowed.  If false, editing is allowed. */
	Locked: boolean;
	/** If true the part will be massless when welded to another part that is not massless. The part will still have mass like a normal part if it is an assembly root part according to GetRootPart(). */
	Massless: boolean;
	/** Specifies the look and feel the Part should have.  Note: this does not define the color the Part is, see BrickColor for that. [More info](http://wiki.roblox.com/index.php/Material) */
	Material: Enum.Material;
	/** Rotation around X, Y, and Z axis.  Rotations applied in YXZ order. */
	Orientation: Vector3;
	Position: Vector3;
	readonly ReceiveAge: number;
	/** Specifies how shiny the Part is. A value of 1 is completely reflective (chrome), while a value of 0 is no reflectance (concrete wall) */
	Reflectance: number;
	/** Sets the value for the smallest change in size allowable by the Resize(NormalId, int) function. */
	readonly ResizeIncrement: number;
	/** Sets the value for the faces allowed to be resized by the Resize(NormalId, int) function. */
	readonly ResizeableFaces: Faces;
	RightParamA: number;
	RightParamB: number;
	RightSurface: Enum.SurfaceType;
	RightSurfaceInput: Enum.InputType;
	/** An integer from -127 to 127. Compares before other all other part properties besides massless for deciding which part is the assembly root part according to GetRootPart(). */
	RootPriority: number;
	RotVelocity: Vector3;
	Rotation: Vector3;
	Size: Vector3;
	TopParamA: number;
	TopParamB: number;
	TopSurface: Enum.SurfaceType;
	TopSurfaceInput: Enum.InputType;
	/** Sets how visible an object is. A value of 1 makes the object invisible, while a value of 0 makes the object opaque. */
	Transparency: number;
	/** How fast the Part is traveling in studs/second. This property is NOT recommended to be modified directly, unless there is good reason.  Otherwise, try using a BodyForce to move a Part. */
	Velocity: Vector3;
	/** Destroys SurfaceJoints with all parts that are touching this Instance (including internal joints in the Instance, as in a Model). */
	BreakJoints(): void;
	/** Returns a number that is the mass of this Instance.  Mass of a Part is immutable, and is changed only by the size of the Part. */
	GetMass(): number;
	GetNetworkOwnershipAuto(): boolean;
	IsGrounded(): boolean;
	/** Creates the appropriate SurfaceJoints with all parts that are touching this Instance (including internal joints in the Instance, as in a Model).  This uses the SurfaceTypes defined on the surfaces of parts to create the appropriate welds. [More info](http://wiki.roblox.com/index.php/MakeJoints) */
	MakeJoints(): void;
	/** Resizes a Part in the direction of the face defined by 'NormalId', by the amount specified by 'deltaAmount'. If the operation will expand the part to intersect another Instance, the part will not resize at all.  Return true if the call is successful, false otherwise. */
	Resize(normalId: Enum.NormalId, deltaAmount: number): boolean;
	SetNetworkOwnershipAuto(): void;
}
type BasePart = CornerWedgePart | FormFactorPart | MeshPart | DerivesFromPartOperation | Terrain | TrussPart | VehicleSeat;

// CornerWedgePart
interface RbxCornerWedgePart extends RbxBasePart {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "CornerWedgePart";
}
type CornerWedgePart = RbxCornerWedgePart & Indexable<RbxCornerWedgePart>;

// FormFactorPart
interface RbxFormFactorPart extends RbxBasePart {
}
type FormFactorPart = DerivesFromPart | WedgePart;

// DerivesFromPart
interface RbxDerivesFromPart extends RbxFormFactorPart {
	Shape: Enum.PartType;
}
interface RbxPart extends RbxDerivesFromPart {
	readonly ClassName: "Part";
}

type Part = RbxPart & Indexable<RbxPart>;
type DerivesFromPart = Part | FlagStand | Platform | Seat | SkateboardPlatform | SpawnLocation;

// FlagStand
interface RbxFlagStand extends RbxDerivesFromPart {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "FlagStand";
	TeamColor: BrickColor;
}
type FlagStand = RbxFlagStand & Indexable<RbxFlagStand>;

// Platform
interface RbxPlatform extends RbxDerivesFromPart {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Platform";
}
type Platform = RbxPlatform & Indexable<RbxPlatform>;

// Seat
interface RbxSeat extends RbxDerivesFromPart {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Seat";
	Disabled: boolean;
	readonly Occupant?: Humanoid;
	Sit(humanoid: Instance): void;
}
type Seat = RbxSeat & Indexable<RbxSeat>;

// SkateboardPlatform
interface RbxSkateboardPlatform extends RbxDerivesFromPart {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "SkateboardPlatform";
	readonly Controller?: SkateboardController;
	readonly ControllingHumanoid?: Humanoid;
	Steer: number;
	StickyWheels: boolean;
	Throttle: number;
	ApplySpecificImpulse(impulseWorld: Vector3): void;
	readonly Equipped: RBXScriptSignal<(humanoid: Instance, skateboardController: Instance) => void>;
	readonly MoveStateChanged: RBXScriptSignal<(newState: Enum.MoveState, oldState: Enum.MoveState) => void>;
	readonly Unequipped: RBXScriptSignal<(humanoid: Instance) => void>;
}
type SkateboardPlatform = RbxSkateboardPlatform & Indexable<RbxSkateboardPlatform>;

// SpawnLocation
interface RbxSpawnLocation extends RbxDerivesFromPart {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "SpawnLocation";
	AllowTeamChangeOnTouch: boolean;
	Duration: number;
	Enabled: boolean;
	Neutral: boolean;
	TeamColor: BrickColor;
}
type SpawnLocation = RbxSpawnLocation & Indexable<RbxSpawnLocation>;

// WedgePart
interface RbxWedgePart extends RbxFormFactorPart {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "WedgePart";
}
type WedgePart = RbxWedgePart & Indexable<RbxWedgePart>;

// MeshPart
interface RbxMeshPart extends RbxBasePart {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "MeshPart";
	readonly MeshId: string;
	TextureID: string;
}
type MeshPart = RbxMeshPart & Indexable<RbxMeshPart>;

// DerivesFromPartOperation
interface RbxDerivesFromPartOperation extends RbxBasePart {
	readonly RenderFidelity: Enum.RenderFidelity;
	readonly TriangleCount: number;
	UsePartColor: boolean;
}
interface RbxPartOperation extends RbxDerivesFromPartOperation {
	readonly ClassName: "PartOperation";
}

type PartOperation = RbxPartOperation & Indexable<RbxPartOperation>;
type DerivesFromPartOperation = PartOperation | NegateOperation | UnionOperation;

// NegateOperation
interface RbxNegateOperation extends RbxDerivesFromPartOperation {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "NegateOperation";
}
type NegateOperation = RbxNegateOperation & Indexable<RbxNegateOperation>;

// UnionOperation
interface RbxUnionOperation extends RbxDerivesFromPartOperation {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "UnionOperation";
}
type UnionOperation = RbxUnionOperation & Indexable<RbxUnionOperation>;

// Terrain
interface RbxTerrain extends RbxBasePart {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Terrain";
	readonly MaxExtents: Region3int16;
	WaterColor: Color3;
	WaterReflectance: number;
	WaterTransparency: number;
	WaterWaveSize: number;
	WaterWaveSpeed: number;
	CellCenterToWorld(x: number, y: number, z: number): Vector3;
	CellCornerToWorld(x: number, y: number, z: number): Vector3;
	Clear(): void;
	CountCells(): number;
	FillBall(center: Vector3, radius: number, material: Enum.Material): void;
	FillBlock(cframe: CFrame, size: Vector3, material: Enum.Material): void;
	FillRegion(region: Region3, resolution: number, material: Enum.Material): void;
	GetMaterialColor(material: Enum.Material): Color3;
	SetMaterialColor(material: Enum.Material, value: Color3): void;
	WorldToCell(position: Vector3): Vector3;
	WorldToCellPreferEmpty(position: Vector3): Vector3;
	WorldToCellPreferSolid(position: Vector3): Vector3;
}
type Terrain = RbxTerrain & Indexable<RbxTerrain>;

// TrussPart
interface RbxTrussPart extends RbxBasePart {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "TrussPart";
	Style: Enum.Style;
}
type TrussPart = RbxTrussPart & Indexable<RbxTrussPart>;

// VehicleSeat
interface RbxVehicleSeat extends RbxBasePart {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "VehicleSeat";
	readonly AreHingesDetected: number;
	Disabled: boolean;
	HeadsUpDisplay: boolean;
	MaxSpeed: number;
	readonly Occupant?: Humanoid;
	Steer: number;
	SteerFloat: number;
	Throttle: number;
	ThrottleFloat: number;
	Torque: number;
	TurnSpeed: number;
	Sit(humanoid: Instance): void;
}
type VehicleSeat = RbxVehicleSeat & Indexable<RbxVehicleSeat>;

// DerivesFromModel
interface RbxDerivesFromModel extends RbxPVInstance {
	PrimaryPart?: BasePart;
	BreakJoints(): void;
	GetBoundingBox(): unknown;
	GetExtentsSize(): Vector3;
	GetPrimaryPartCFrame(): CFrame;
	MakeJoints(): void;
	MoveTo(position: Vector3): void;
	SetPrimaryPartCFrame(cframe: CFrame): void;
	TranslateBy(delta: Vector3): void;
}
interface RbxModel extends RbxDerivesFromModel {
	readonly ClassName: "Model";
}

type Model = RbxModel & Indexable<RbxModel>;
type DerivesFromModel = Model | Status | Workspace;

// Status
interface RbxStatus extends RbxDerivesFromModel {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Status";
}
type Status = RbxStatus & Indexable<RbxStatus>;

// Workspace
interface RbxWorkspace extends RbxDerivesFromModel {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Workspace";
	AllowThirdPartySales: boolean;
	CurrentCamera?: Camera;
	DistributedGameTime: number;
	/** Sets the height at which falling characters and parts are destroyed. This property is not scriptable and can only be set in Studio */
	readonly FallenPartsDestroyHeight: number;
	readonly FilteringEnabled: boolean;
	Gravity: number;
	StreamingEnabled: boolean;
	/** Returns parts in the area defined by the Region3, up to specified maxCount or 100, whichever is less */
	FindPartsInRegion3(region: Region3, ignoreDescendantsInstance?: Instance, maxParts?: number): Array<Instance>;
	/** Returns parts in the area defined by the Region3, up to specified maxCount or 100, whichever is less */
	FindPartsInRegion3WithIgnoreList(region: Region3, ignoreDescendantsTable: Array<Instance>, maxParts?: number): Array<Instance>;
	FindPartsInRegion3WithWhiteList(region: Region3, whitelistDescendantsTable: Array<Instance>, maxParts?: number): Array<Instance>;
	GetNumAwakeParts(): number;
	GetPhysicsThrottling(): number;
	GetRealPhysicsFPS(): number;
	IsRegion3Empty(region: Region3, ignoreDescendentsInstance?: Instance): boolean;
	IsRegion3EmptyWithIgnoreList(region: Region3, ignoreDescendentsTable: Array<Instance>): boolean;
	JoinToOutsiders(objects: Array<Instance>, jointType: Enum.JointCreationMode): void;
	PGSIsEnabled(): boolean;
	UnjoinFromOutsiders(objects: Array<Instance>): void;
}
type Workspace = RbxWorkspace & Indexable<RbxWorkspace>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "Workspace"): Workspace;
}

// PackageLink
interface RbxPackageLink extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "PackageLink";
	readonly PackageId: string;
	readonly VersionNumber: number;
}
type PackageLink = RbxPackageLink & Indexable<RbxPackageLink>;

// Pages
interface RbxPages extends RbxInstance {
	readonly IsFinished: boolean;
	GetCurrentPage(): unknown;
	AdvanceToNextPageAsync(): void;
}
type Pages = DataStorePages | FriendPages | InventoryPages | StandardPages;

// DataStorePages
interface RbxDataStorePages extends RbxPages {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "DataStorePages";
}
type DataStorePages = RbxDataStorePages & Indexable<RbxDataStorePages>;

// FriendPages
interface RbxFriendPages extends RbxPages {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "FriendPages";
}
type FriendPages = RbxFriendPages & Indexable<RbxFriendPages>;

// InventoryPages
interface RbxInventoryPages extends RbxPages {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "InventoryPages";
}
type InventoryPages = RbxInventoryPages & Indexable<RbxInventoryPages>;

// StandardPages
interface RbxStandardPages extends RbxPages {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "StandardPages";
}
type StandardPages = RbxStandardPages & Indexable<RbxStandardPages>;

// PartOperationAsset
interface RbxPartOperationAsset extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "PartOperationAsset";
}
type PartOperationAsset = RbxPartOperationAsset & Indexable<RbxPartOperationAsset>;

// ParticleEmitter
interface RbxParticleEmitter extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ParticleEmitter";
	Acceleration: Vector3;
	Color: ColorSequence;
	Drag: number;
	EmissionDirection: Enum.NormalId;
	Enabled: boolean;
	Lifetime: NumberRange;
	LightEmission: number;
	/** Specifies the amount of influence lighting has on the particle emmitter. A value of 0 is unlit, 1 is fully lit. Fractional values blend from unlit to lit. */
	LightInfluence: number;
	LockedToPart: boolean;
	Rate: number;
	RotSpeed: NumberRange;
	Rotation: NumberRange;
	Size: NumberSequence;
	Speed: NumberRange;
	SpreadAngle: Vector2;
	Texture: string;
	Transparency: NumberSequence;
	VelocityInheritance: number;
	ZOffset: number;
	Clear(): void;
	Emit(particleCount?: number): void;
}
type ParticleEmitter = RbxParticleEmitter & Indexable<RbxParticleEmitter>;

// Path
interface RbxPath extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Path";
	readonly Status: Enum.PathStatus;
	CheckOcclusionAsync(start: number): number;
	ComputeAsync(start: Vector3, finish: Vector3): void;
	readonly Blocked: RBXScriptSignal<(blockedWaypointIdx: number) => void>;
}
type Path = RbxPath & Indexable<RbxPath>;

// PathfindingService
interface RbxPathfindingService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "PathfindingService";
}
type PathfindingService = RbxPathfindingService & Indexable<RbxPathfindingService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "PathfindingService"): PathfindingService;
}

// PhysicsPacketCache
interface RbxPhysicsPacketCache extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "PhysicsPacketCache";
}
type PhysicsPacketCache = RbxPhysicsPacketCache & Indexable<RbxPhysicsPacketCache>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "PhysicsPacketCache"): PhysicsPacketCache;
}

// PhysicsService
interface RbxPhysicsService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "PhysicsService";
	CollisionGroupContainsPart(name: string, part: Instance): boolean;
	CollisionGroupSetCollidable(name1: string, name2: string, collidable: boolean): void;
	CollisionGroupsAreCollidable(name1: string, name2: string): boolean;
	CreateCollisionGroup(name: string): number;
	GetCollisionGroupId(name: string): number;
	GetCollisionGroupName(name: number): string;
	GetMaxCollisionGroups(): number;
	RemoveCollisionGroup(name: string): void;
	RenameCollisionGroup(from: string, to: string): void;
	SetPartCollisionGroup(part: Instance, name: string): void;
}
type PhysicsService = RbxPhysicsService & Indexable<RbxPhysicsService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "PhysicsService"): PhysicsService;
}

// PhysicsSettings
interface RbxPhysicsSettings extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "PhysicsSettings";
	AllowSleep: boolean;
	AreAnchorsShown: boolean;
	AreAssembliesShown: boolean;
	AreAwakePartsHighlighted: boolean;
	AreBodyTypesShown: boolean;
	AreContactIslandsShown: boolean;
	AreContactPointsShown: boolean;
	AreJointCoordinatesShown: boolean;
	AreMechanismsShown: boolean;
	AreModelCoordsShown: boolean;
	AreOwnersShown: boolean;
	ArePartCoordsShown: boolean;
	AreRegionsShown: boolean;
	AreUnalignedPartsShown: boolean;
	AreWorldCoordsShown: boolean;
	DisableCSGv2: boolean;
	IsReceiveAgeShown: boolean;
	IsTreeShown: boolean;
	PhysicsEnvironmentalThrottle: Enum.EnviromentalPhysicsThrottle;
	ShowDecompositionGeometry: boolean;
	ThrottleAdjustTime: number;
	UseCSGv2: boolean;
}
type PhysicsSettings = RbxPhysicsSettings & Indexable<RbxPhysicsSettings>;

// Player
interface RbxPlayer extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Player";
	readonly AccountAge: number;
	AutoJumpEnabled: boolean;
	CameraMaxZoomDistance: number;
	CameraMinZoomDistance: number;
	/** An enum that describes how a Player's camera is allowed to behave. [More info](http://wiki.roblox.com/index.php/CameraMode). */
	CameraMode: Enum.CameraMode;
	CanLoadCharacterAppearance: boolean;
	CharacterAppearanceId: number;
	DevCameraOcclusionMode: Enum.DevCameraOcclusionMode;
	DevComputerCameraMode: Enum.DevComputerCameraMovementMode;
	DevComputerMovementMode: Enum.DevComputerMovementMode;
	DevEnableMouseLock: boolean;
	DevTouchCameraMode: Enum.DevTouchCameraMovementMode;
	DevTouchMovementMode: Enum.DevTouchMovementMode;
	readonly FollowUserId: number;
	HealthDisplayDistance: number;
	readonly LocaleId: string;
	readonly MembershipType: Enum.MembershipType;
	NameDisplayDistance: number;
	Neutral: boolean;
	RespawnLocation?: SpawnLocation;
	Team?: Team;
	TeamColor: BrickColor;
	UserId: number;
	ClearCharacterAppearance(): void;
	DistanceFromCharacter(point: Vector3): number;
	GetJoinData(): object;
	HasAppearanceLoaded(): boolean;
	Kick(message?: string): void;
	Move(walkDirection: Vector3, relativeToCamera?: boolean): void;
	GetRankInGroup(groupId: number): number;
	GetRoleInGroup(groupId: number): string;
	IsFriendsWith(userId: number): boolean;
	IsInGroup(groupId: number): boolean;
	readonly Chatted: RBXScriptSignal<(message: string, recipient: Instance) => void>;
	/** Fired periodically after the user has been AFK for a while.  Currently this event is only fired for the *local* Player.  "time" is the time in seconds that the user has been idle. */
	readonly Idled: RBXScriptSignal<(time: number) => void>;
	readonly OnTeleport: RBXScriptSignal<(teleportState: Enum.TeleportState, placeId: number, spawnName: string) => void>;
}
type Player = RbxPlayer & Indexable<RbxPlayer>;

// PlayerScripts
interface RbxPlayerScripts extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "PlayerScripts";
	ClearComputerCameraMovementModes(): void;
	ClearComputerMovementModes(): void;
	ClearTouchCameraMovementModes(): void;
	ClearTouchMovementModes(): void;
	RegisterComputerCameraMovementMode(cameraMovementMode: Enum.ComputerCameraMovementMode): void;
	RegisterComputerMovementMode(movementMode: Enum.ComputerMovementMode): void;
	RegisterTouchCameraMovementMode(cameraMovementMode: Enum.TouchCameraMovementMode): void;
	RegisterTouchMovementMode(movementMode: Enum.TouchMovementMode): void;
}
type PlayerScripts = RbxPlayerScripts & Indexable<RbxPlayerScripts>;

// Players
interface RbxPlayers extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Players";
	readonly BubbleChat: boolean;
	/** Set to true, when a player joins a game, they get a character automatically, as well as when they die.  When set to false, characters do not auto load and will only load in using Player:LoadCharacter(). */
	CharacterAutoLoads: boolean;
	readonly ClassicChat: boolean;
	readonly MaxPlayers: number;
	readonly PreferredPlayers: number;
	RespawnTime: number;
	GetNameFromUserIdAsync(userId: number): string;
	GetUserIdFromNameAsync(userName: string): number;
}
type Players = RbxPlayers & Indexable<RbxPlayers>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "Players"): Players;
}

// Plugin
interface RbxPlugin extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Plugin";
	readonly CollisionEnabled: boolean;
	readonly GridSize: number;
}
type Plugin = RbxPlugin & Indexable<RbxPlugin>;

// PluginAction
interface RbxPluginAction extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "PluginAction";
	readonly ActionId: string;
	readonly AllowBinding: boolean;
	readonly StatusTip: string;
	readonly Text: string;
}
type PluginAction = RbxPluginAction & Indexable<RbxPluginAction>;

// PluginDragEvent
interface RbxPluginDragEvent extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "PluginDragEvent";
	readonly Data: string;
	readonly MimeType: string;
	readonly Position: Vector2;
	readonly Sender: string;
}
type PluginDragEvent = RbxPluginDragEvent & Indexable<RbxPluginDragEvent>;

// PluginGuiService
interface RbxPluginGuiService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "PluginGuiService";
}
type PluginGuiService = RbxPluginGuiService & Indexable<RbxPluginGuiService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "PluginGuiService"): PluginGuiService;
}

// PluginManager
interface RbxPluginManager extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "PluginManager";
}
type PluginManager = RbxPluginManager & Indexable<RbxPluginManager>;

// PluginMenu
interface RbxPluginMenu extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "PluginMenu";
	Icon: string;
	Title: string;
}
type PluginMenu = RbxPluginMenu & Indexable<RbxPluginMenu>;

// PluginToolbar
interface RbxPluginToolbar extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "PluginToolbar";
}
type PluginToolbar = RbxPluginToolbar & Indexable<RbxPluginToolbar>;

// PluginToolbarButton
interface RbxPluginToolbarButton extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "PluginToolbarButton";
	ClickableWhenViewportHidden: boolean;
	Enabled: boolean;
	Icon: string;
}
type PluginToolbarButton = RbxPluginToolbarButton & Indexable<RbxPluginToolbarButton>;

// PointsService
interface RbxPointsService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "PointsService";
	/** Fired when points are successfully awarded 'userId'. Also returns the updated balance of points for usedId in universe via 'userBalanceInUniverse', total points via 'userTotalBalance', and the amount points that were awarded via 'pointsAwarded'. This event fires on the server and also all clients in the game that awarded the points. */
	readonly PointsAwarded: RBXScriptSignal<(userId: number, pointsAwarded: number, userBalanceInGame: number, userTotalBalance: number) => void>;
}
type PointsService = RbxPointsService & Indexable<RbxPointsService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "PointsService"): PointsService;
}

// Pose
interface RbxPose extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Pose";
	CFrame: CFrame;
	EasingDirection: Enum.PoseEasingDirection;
	EasingStyle: Enum.PoseEasingStyle;
	Weight: number;
	AddSubPose(pose: Instance): void;
	GetSubPoses(): Array<Instance>;
	RemoveSubPose(pose: Instance): void;
}
type Pose = RbxPose & Indexable<RbxPose>;

// PostEffect
interface RbxPostEffect extends RbxInstance {
	Enabled: boolean;
}
type PostEffect = BloomEffect | BlurEffect | ColorCorrectionEffect | SunRaysEffect;

// BloomEffect
interface RbxBloomEffect extends RbxPostEffect {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "BloomEffect";
	Intensity: number;
	Size: number;
	Threshold: number;
}
type BloomEffect = RbxBloomEffect & Indexable<RbxBloomEffect>;

// BlurEffect
interface RbxBlurEffect extends RbxPostEffect {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "BlurEffect";
	Size: number;
}
type BlurEffect = RbxBlurEffect & Indexable<RbxBlurEffect>;

// ColorCorrectionEffect
interface RbxColorCorrectionEffect extends RbxPostEffect {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ColorCorrectionEffect";
	Brightness: number;
	Contrast: number;
	Saturation: number;
	TintColor: Color3;
}
type ColorCorrectionEffect = RbxColorCorrectionEffect & Indexable<RbxColorCorrectionEffect>;

// SunRaysEffect
interface RbxSunRaysEffect extends RbxPostEffect {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "SunRaysEffect";
	Intensity: number;
	Spread: number;
}
type SunRaysEffect = RbxSunRaysEffect & Indexable<RbxSunRaysEffect>;

// ReflectionMetadata
interface RbxReflectionMetadata extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ReflectionMetadata";
}
type ReflectionMetadata = RbxReflectionMetadata & Indexable<RbxReflectionMetadata>;

// ReflectionMetadataCallbacks
interface RbxReflectionMetadataCallbacks extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ReflectionMetadataCallbacks";
}
type ReflectionMetadataCallbacks = RbxReflectionMetadataCallbacks & Indexable<RbxReflectionMetadataCallbacks>;

// ReflectionMetadataClasses
interface RbxReflectionMetadataClasses extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ReflectionMetadataClasses";
}
type ReflectionMetadataClasses = RbxReflectionMetadataClasses & Indexable<RbxReflectionMetadataClasses>;

// ReflectionMetadataEnums
interface RbxReflectionMetadataEnums extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ReflectionMetadataEnums";
}
type ReflectionMetadataEnums = RbxReflectionMetadataEnums & Indexable<RbxReflectionMetadataEnums>;

// ReflectionMetadataEvents
interface RbxReflectionMetadataEvents extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ReflectionMetadataEvents";
}
type ReflectionMetadataEvents = RbxReflectionMetadataEvents & Indexable<RbxReflectionMetadataEvents>;

// ReflectionMetadataFunctions
interface RbxReflectionMetadataFunctions extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ReflectionMetadataFunctions";
}
type ReflectionMetadataFunctions = RbxReflectionMetadataFunctions & Indexable<RbxReflectionMetadataFunctions>;

// ReflectionMetadataItem
interface RbxReflectionMetadataItem extends RbxInstance {
	Browsable: boolean;
	ClassCategory: string;
	ClientOnly: boolean;
	Constraint: string;
	Deprecated: boolean;
	EditingDisabled: boolean;
	IsBackend: boolean;
	ScriptContext: string;
	ServerOnly: boolean;
	UIMaximum: number;
	UIMinimum: number;
	UINumTicks: number;
	summary: string;
}
type ReflectionMetadataItem = ReflectionMetadataClass | ReflectionMetadataEnum | ReflectionMetadataEnumItem | ReflectionMetadataMember;

// ReflectionMetadataClass
interface RbxReflectionMetadataClass extends RbxReflectionMetadataItem {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ReflectionMetadataClass";
	ExplorerImageIndex: number;
	ExplorerOrder: number;
	Insertable: boolean;
	PreferredParent: string;
	PreferredParents: string;
}
type ReflectionMetadataClass = RbxReflectionMetadataClass & Indexable<RbxReflectionMetadataClass>;

// ReflectionMetadataEnum
interface RbxReflectionMetadataEnum extends RbxReflectionMetadataItem {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ReflectionMetadataEnum";
}
type ReflectionMetadataEnum = RbxReflectionMetadataEnum & Indexable<RbxReflectionMetadataEnum>;

// ReflectionMetadataEnumItem
interface RbxReflectionMetadataEnumItem extends RbxReflectionMetadataItem {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ReflectionMetadataEnumItem";
}
type ReflectionMetadataEnumItem = RbxReflectionMetadataEnumItem & Indexable<RbxReflectionMetadataEnumItem>;

// ReflectionMetadataMember
interface RbxReflectionMetadataMember extends RbxReflectionMetadataItem {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ReflectionMetadataMember";
}
type ReflectionMetadataMember = RbxReflectionMetadataMember & Indexable<RbxReflectionMetadataMember>;

// ReflectionMetadataProperties
interface RbxReflectionMetadataProperties extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ReflectionMetadataProperties";
}
type ReflectionMetadataProperties = RbxReflectionMetadataProperties & Indexable<RbxReflectionMetadataProperties>;

// ReflectionMetadataYieldFunctions
interface RbxReflectionMetadataYieldFunctions extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ReflectionMetadataYieldFunctions";
}
type ReflectionMetadataYieldFunctions = RbxReflectionMetadataYieldFunctions & Indexable<RbxReflectionMetadataYieldFunctions>;

// RemoteEvent
interface RbxRemoteEvent extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "RemoteEvent";
}
type RemoteEvent = RbxRemoteEvent & Indexable<RbxRemoteEvent>;

// RemoteFunction
interface RbxRemoteFunction extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "RemoteFunction";
}
type RemoteFunction = RbxRemoteFunction & Indexable<RbxRemoteFunction>;

// RenderSettings
interface RbxRenderSettings extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "RenderSettings";
	AutoFRMLevel: number;
	EagerBulkExecution: boolean;
	EditQualityLevel: Enum.QualityLevel;
	EnableFRM: boolean;
	ExportMergeByMaterial: boolean;
	FrameRateManager: Enum.FramerateManagerMode;
	GraphicsMode: Enum.GraphicsMode;
	MeshCacheSize: number;
	QualityLevel: Enum.QualityLevel;
	ReloadAssets: boolean;
	RenderCSGTrianglesDebug: boolean;
	ShowBoundingBoxes: boolean;
	GetMaxQualityLevel(): number;
}
type RenderSettings = RbxRenderSettings & Indexable<RbxRenderSettings>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "RenderSettings"): RenderSettings;
}

// RenderingTest
interface RbxRenderingTest extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "RenderingTest";
	CFrame: CFrame;
	ComparisonDiffThreshold: number;
	ComparisonMethod: Enum.RenderingTestComparisonMethod;
	ComparisonPsnrThreshold: number;
	Description: string;
	FieldOfView: number;
	Orientation: Vector3;
	Position: Vector3;
	QualityLevel: number;
	ShouldSkip: boolean;
	Ticket: string;
}
type RenderingTest = RbxRenderingTest & Indexable<RbxRenderingTest>;

// ReplicatedFirst
interface RbxReplicatedFirst extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ReplicatedFirst";
	RemoveDefaultLoadingScreen(): void;
}
type ReplicatedFirst = RbxReplicatedFirst & Indexable<RbxReplicatedFirst>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "ReplicatedFirst"): ReplicatedFirst;
}

// ReplicatedStorage
interface RbxReplicatedStorage extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ReplicatedStorage";
}
type ReplicatedStorage = RbxReplicatedStorage & Indexable<RbxReplicatedStorage>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "ReplicatedStorage"): ReplicatedStorage;
}

// RobloxReplicatedStorage
interface RbxRobloxReplicatedStorage extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "RobloxReplicatedStorage";
}
type RobloxReplicatedStorage = RbxRobloxReplicatedStorage & Indexable<RbxRobloxReplicatedStorage>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "RobloxReplicatedStorage"): RobloxReplicatedStorage;
}

// RunService
interface RbxRunService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "RunService";
	BindToRenderStep(name: string, priority: number, callback: Function): void;
	IsClient(): boolean;
	IsRunMode(): boolean;
	IsRunning(): boolean;
	IsServer(): boolean;
	IsStudio(): boolean;
	UnbindFromRenderStep(name: string): void;
	readonly Heartbeat: RBXScriptSignal<(step: number) => void>;
	readonly RenderStepped: RBXScriptSignal<(step: number) => void>;
	readonly Stepped: RBXScriptSignal<(time: number, step: number) => void>;
}
type RunService = RbxRunService & Indexable<RbxRunService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "RunService"): RunService;
}

// RuntimeScriptService
interface RbxRuntimeScriptService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "RuntimeScriptService";
}
type RuntimeScriptService = RbxRuntimeScriptService & Indexable<RbxRuntimeScriptService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "RuntimeScriptService"): RuntimeScriptService;
}

// ScriptContext
interface RbxScriptContext extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ScriptContext";
	readonly Error: RBXScriptSignal<(message: string, stackTrace: string, script: Instance) => void>;
}
type ScriptContext = RbxScriptContext & Indexable<RbxScriptContext>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "ScriptContext"): ScriptContext;
}

// ScriptDebugger
interface RbxScriptDebugger extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ScriptDebugger";
	readonly CurrentLine: number;
	readonly IsDebugging: boolean;
	readonly IsPaused: boolean;
	readonly Script?: Instance;
	AddWatch(expression: string): Instance | undefined;
	GetBreakpoints(): Array<Instance>;
	GetGlobals(): object;
	GetLocals(stackFrame?: number): object;
	GetStack(): unknown;
	GetUpvalues(stackFrame?: number): object;
	GetWatchValue(watch: Instance): unknown;
	GetWatches(): Array<Instance>;
	SetBreakpoint(line: number): Instance | undefined;
	SetGlobal(name: string, value?: any): void;
	SetLocal(name: string, value?: any, stackFrame?: number): void;
	SetUpvalue(name: string, value?: any, stackFrame?: number): void;
	readonly BreakpointAdded: RBXScriptSignal<(breakpoint: Instance) => void>;
	readonly BreakpointRemoved: RBXScriptSignal<(breakpoint: Instance) => void>;
	readonly EncounteredBreak: RBXScriptSignal<(line: number) => void>;
	readonly Resuming: RBXScriptSignal<() => void>;
	readonly WatchAdded: RBXScriptSignal<(watch: Instance) => void>;
	readonly WatchRemoved: RBXScriptSignal<(watch: Instance) => void>;
}
type ScriptDebugger = RbxScriptDebugger & Indexable<RbxScriptDebugger>;

// ScriptService
interface RbxScriptService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ScriptService";
}
type ScriptService = RbxScriptService & Indexable<RbxScriptService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "ScriptService"): ScriptService;
}

// Selection
interface RbxSelection extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Selection";
	readonly SelectionChanged: RBXScriptSignal<() => void>;
}
type Selection = RbxSelection & Indexable<RbxSelection>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "Selection"): Selection;
}

// ServerScriptService
interface RbxServerScriptService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ServerScriptService";
}
type ServerScriptService = RbxServerScriptService & Indexable<RbxServerScriptService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "ServerScriptService"): ServerScriptService;
}

// ServerStorage
interface RbxServerStorage extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ServerStorage";
}
type ServerStorage = RbxServerStorage & Indexable<RbxServerStorage>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "ServerStorage"): ServerStorage;
}

// ServiceProvider
interface RbxServiceProvider extends RbxInstance {
	FindService(className: string): Instance | undefined;
	GetService(className: string): Instance | undefined;
	readonly Close: RBXScriptSignal<() => void>;
	readonly ServiceAdded: RBXScriptSignal<(service: Instance) => void>;
	readonly ServiceRemoving: RBXScriptSignal<(service: Instance) => void>;
}
type ServiceProvider = DataModel | GenericSettings;

// DataModel
interface RbxDataModel extends RbxServiceProvider {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "DataModel";
	readonly CreatorId: number;
	readonly CreatorType: Enum.CreatorType;
	readonly GameId: number;
	readonly GearGenreSetting: Enum.GearGenreSetting;
	readonly Genre: Enum.Genre;
	readonly JobId: string;
	readonly PlaceId: number;
	readonly PlaceVersion: number;
	readonly PrivateServerId: string;
	readonly PrivateServerOwnerId: number;
	BindToClose(callback: Function): void;
	IsGearTypeAllowed(gearType: Enum.GearType): boolean;
	IsLoaded(): boolean;
	readonly GraphicsQualityChangeRequest: RBXScriptSignal<(betterQuality: boolean) => void>;
	/** Fires when the game finishes loading.  Use this to know when to remove your custom loading gui.  It is best to check IsLoaded() before connecting to this event, as the game may load before the event is connected to. */
	readonly Loaded: RBXScriptSignal<() => void>;
}
type DataModel = RbxDataModel & Indexable<RbxDataModel>;

// GenericSettings
interface RbxGenericSettings extends RbxServiceProvider {
}
type GenericSettings = AnalysticsSettings | GlobalSettings | UserSettings;

// AnalysticsSettings
interface RbxAnalysticsSettings extends RbxGenericSettings {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "AnalysticsSettings";
}
type AnalysticsSettings = RbxAnalysticsSettings & Indexable<RbxAnalysticsSettings>;

// GlobalSettings
interface RbxGlobalSettings extends RbxGenericSettings {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "GlobalSettings";
	GetFFlag(name: string): boolean;
	GetFVariable(name: string): string;
}
type GlobalSettings = RbxGlobalSettings & Indexable<RbxGlobalSettings>;

// UserSettings
interface RbxUserSettings extends RbxGenericSettings {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "UserSettings";
	IsUserFeatureEnabled(name: string): boolean;
	Reset(): void;
}
type UserSettings = RbxUserSettings & Indexable<RbxUserSettings>;

// Sky
interface RbxSky extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Sky";
	CelestialBodiesShown: boolean;
	MoonAngularSize: number;
	MoonTextureId: string;
	SkyboxBk: string;
	SkyboxDn: string;
	SkyboxFt: string;
	SkyboxLf: string;
	SkyboxRt: string;
	SkyboxUp: string;
	StarCount: number;
	SunAngularSize: number;
	SunTextureId: string;
}
type Sky = RbxSky & Indexable<RbxSky>;

// Smoke
interface RbxSmoke extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Smoke";
	Color: Color3;
	Enabled: boolean;
	Opacity: number;
	RiseVelocity: number;
	Size: number;
}
type Smoke = RbxSmoke & Indexable<RbxSmoke>;

// SocialService
interface RbxSocialService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "SocialService";
}
type SocialService = RbxSocialService & Indexable<RbxSocialService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "SocialService"): SocialService;
}

// Sound
interface RbxSound extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Sound";
	EmitterSize: number;
	readonly IsLoaded: boolean;
	readonly IsPaused: boolean;
	readonly IsPlaying: boolean;
	Looped: boolean;
	MaxDistance: number;
	/** The sound will play when it is removed from the Workspace. Looped sounds don't play */
	PlayOnRemove: boolean;
	readonly PlaybackLoudness: number;
	PlaybackSpeed: number;
	Playing: boolean;
	RollOffMode: Enum.RollOffMode;
	SoundGroup?: SoundGroup;
	SoundId: string;
	readonly TimeLength: number;
	TimePosition: number;
	Volume: number;
	Pause(): void;
	Play(): void;
	Resume(): void;
	Stop(): void;
	readonly DidLoop: RBXScriptSignal<(soundId: string, numOfTimesLooped: number) => void>;
	readonly Ended: RBXScriptSignal<(soundId: string) => void>;
	readonly Loaded: RBXScriptSignal<(soundId: string) => void>;
	readonly Paused: RBXScriptSignal<(soundId: string) => void>;
	readonly Played: RBXScriptSignal<(soundId: string) => void>;
	readonly Resumed: RBXScriptSignal<(soundId: string) => void>;
	readonly Stopped: RBXScriptSignal<(soundId: string) => void>;
}
type Sound = RbxSound & Indexable<RbxSound>;

// SoundEffect
interface RbxSoundEffect extends RbxInstance {
	Enabled: boolean;
	Priority: number;
}
type SoundEffect = ChorusSoundEffect | CompressorSoundEffect | DistortionSoundEffect | EchoSoundEffect | EqualizerSoundEffect | FlangeSoundEffect | PitchShiftSoundEffect | ReverbSoundEffect | TremoloSoundEffect;

// ChorusSoundEffect
interface RbxChorusSoundEffect extends RbxSoundEffect {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ChorusSoundEffect";
	Depth: number;
	Mix: number;
	Rate: number;
}
type ChorusSoundEffect = RbxChorusSoundEffect & Indexable<RbxChorusSoundEffect>;

// CompressorSoundEffect
interface RbxCompressorSoundEffect extends RbxSoundEffect {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "CompressorSoundEffect";
	Attack: number;
	GainMakeup: number;
	Ratio: number;
	Release: number;
	SideChain?: Instance;
	Threshold: number;
}
type CompressorSoundEffect = RbxCompressorSoundEffect & Indexable<RbxCompressorSoundEffect>;

// DistortionSoundEffect
interface RbxDistortionSoundEffect extends RbxSoundEffect {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "DistortionSoundEffect";
	Level: number;
}
type DistortionSoundEffect = RbxDistortionSoundEffect & Indexable<RbxDistortionSoundEffect>;

// EchoSoundEffect
interface RbxEchoSoundEffect extends RbxSoundEffect {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "EchoSoundEffect";
	Delay: number;
	DryLevel: number;
	Feedback: number;
	WetLevel: number;
}
type EchoSoundEffect = RbxEchoSoundEffect & Indexable<RbxEchoSoundEffect>;

// EqualizerSoundEffect
interface RbxEqualizerSoundEffect extends RbxSoundEffect {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "EqualizerSoundEffect";
	HighGain: number;
	LowGain: number;
	MidGain: number;
}
type EqualizerSoundEffect = RbxEqualizerSoundEffect & Indexable<RbxEqualizerSoundEffect>;

// FlangeSoundEffect
interface RbxFlangeSoundEffect extends RbxSoundEffect {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "FlangeSoundEffect";
	Depth: number;
	Mix: number;
	Rate: number;
}
type FlangeSoundEffect = RbxFlangeSoundEffect & Indexable<RbxFlangeSoundEffect>;

// PitchShiftSoundEffect
interface RbxPitchShiftSoundEffect extends RbxSoundEffect {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "PitchShiftSoundEffect";
	Octave: number;
}
type PitchShiftSoundEffect = RbxPitchShiftSoundEffect & Indexable<RbxPitchShiftSoundEffect>;

// ReverbSoundEffect
interface RbxReverbSoundEffect extends RbxSoundEffect {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ReverbSoundEffect";
	DecayTime: number;
	Density: number;
	Diffusion: number;
	DryLevel: number;
	WetLevel: number;
}
type ReverbSoundEffect = RbxReverbSoundEffect & Indexable<RbxReverbSoundEffect>;

// TremoloSoundEffect
interface RbxTremoloSoundEffect extends RbxSoundEffect {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "TremoloSoundEffect";
	Depth: number;
	Duty: number;
	Frequency: number;
}
type TremoloSoundEffect = RbxTremoloSoundEffect & Indexable<RbxTremoloSoundEffect>;

// SoundGroup
interface RbxSoundGroup extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "SoundGroup";
	Volume: number;
}
type SoundGroup = RbxSoundGroup & Indexable<RbxSoundGroup>;

// SoundService
interface RbxSoundService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "SoundService";
	/** The ambient sound environment.  May not work when using hardware sound */
	AmbientReverb: Enum.ReverbType;
	/** the relative distance factor, compared to 1.0 meters. */
	DistanceFactor: number;
	/** The doppler scale is a general scaling factor for how much the pitch varies due to doppler shifting in 3D sound. Doppler is the pitch bending effect when a sound comes towards the listener or moves away from it, much like the effect you hear when a train goes past you with its horn sounding. With dopplerscale you can exaggerate or diminish the effect. */
	DopplerScale: number;
	RespectFilteringEnabled: boolean;
	/** Setting this value makes the sound drop off faster or slower. The higher the value, the faster volume will attenuate, and conversely the lower the value, the slower it will attenuate. For example a rolloff factor of 1 will simulate the real world, where as a value of 2 will make sounds attenuate 2 times quicker. */
	RolloffScale: number;
	PlayLocalSound(sound: Instance): void;
}
type SoundService = RbxSoundService & Indexable<RbxSoundService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "SoundService"): SoundService;
}

// Sparkles
interface RbxSparkles extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Sparkles";
	Color: Color3;
	Enabled: boolean;
	SparkleColor: Color3;
}
type Sparkles = RbxSparkles & Indexable<RbxSparkles>;

// SpawnerService
interface RbxSpawnerService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "SpawnerService";
}
type SpawnerService = RbxSpawnerService & Indexable<RbxSpawnerService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "SpawnerService"): SpawnerService;
}

// StarterGear
interface RbxStarterGear extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "StarterGear";
}
type StarterGear = RbxStarterGear & Indexable<RbxStarterGear>;

// StarterPack
interface RbxStarterPack extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "StarterPack";
}
type StarterPack = RbxStarterPack & Indexable<RbxStarterPack>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "StarterPack"): StarterPack;
}

// StarterPlayer
interface RbxStarterPlayer extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "StarterPlayer";
	readonly AllowCustomAnimations: boolean;
	AutoJumpEnabled: boolean;
	CameraMaxZoomDistance: number;
	CameraMinZoomDistance: number;
	CameraMode: Enum.CameraMode;
	CharacterJumpHeight: number;
	CharacterJumpPower: number;
	CharacterMaxSlopeAngle: number;
	CharacterUseJumpPower: boolean;
	CharacterWalkSpeed: number;
	DevCameraOcclusionMode: Enum.DevCameraOcclusionMode;
	DevComputerCameraMovementMode: Enum.DevComputerCameraMovementMode;
	DevComputerMovementMode: Enum.DevComputerMovementMode;
	DevTouchCameraMovementMode: Enum.DevTouchCameraMovementMode;
	DevTouchMovementMode: Enum.DevTouchMovementMode;
	EnableMouseLockOption: boolean;
	HealthDisplayDistance: number;
	LoadCharacterAppearance: boolean;
	NameDisplayDistance: number;
}
type StarterPlayer = RbxStarterPlayer & Indexable<RbxStarterPlayer>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "StarterPlayer"): StarterPlayer;
}

// DerivesFromStarterPlayerScripts
interface RbxDerivesFromStarterPlayerScripts extends RbxInstance {
}
interface RbxStarterPlayerScripts extends RbxDerivesFromStarterPlayerScripts {
	readonly ClassName: "StarterPlayerScripts";
}

type StarterPlayerScripts = RbxStarterPlayerScripts & Indexable<RbxStarterPlayerScripts>;
type DerivesFromStarterPlayerScripts = StarterPlayerScripts | StarterCharacterScripts;

// StarterCharacterScripts
interface RbxStarterCharacterScripts extends RbxDerivesFromStarterPlayerScripts {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "StarterCharacterScripts";
}
type StarterCharacterScripts = RbxStarterCharacterScripts & Indexable<RbxStarterCharacterScripts>;

// Stats
interface RbxStats extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Stats";
	readonly ContactsCount: number;
	readonly DataReceiveKbps: number;
	readonly DataSendKbps: number;
	readonly HeartbeatTimeMs: number;
	readonly InstanceCount: number;
	readonly MovingPrimitivesCount: number;
	readonly PhysicsReceiveKbps: number;
	readonly PhysicsSendKbps: number;
	readonly PhysicsStepTimeMs: number;
	readonly PrimitivesCount: number;
	GetMemoryUsageMbForTag(tag: Enum.DeveloperMemoryTag): number;
	GetTotalMemoryUsageMb(): number;
}
type Stats = RbxStats & Indexable<RbxStats>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "Stats"): Stats;
}

// StatsItem
interface RbxStatsItem extends RbxInstance {
}
type StatsItem = RunningAverageItemDouble | RunningAverageItemInt | RunningAverageTimeIntervalItem | TotalCountTimeIntervalItem;

// RunningAverageItemDouble
interface RbxRunningAverageItemDouble extends RbxStatsItem {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "RunningAverageItemDouble";
}
type RunningAverageItemDouble = RbxRunningAverageItemDouble & Indexable<RbxRunningAverageItemDouble>;

// RunningAverageItemInt
interface RbxRunningAverageItemInt extends RbxStatsItem {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "RunningAverageItemInt";
}
type RunningAverageItemInt = RbxRunningAverageItemInt & Indexable<RbxRunningAverageItemInt>;

// RunningAverageTimeIntervalItem
interface RbxRunningAverageTimeIntervalItem extends RbxStatsItem {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "RunningAverageTimeIntervalItem";
}
type RunningAverageTimeIntervalItem = RbxRunningAverageTimeIntervalItem & Indexable<RbxRunningAverageTimeIntervalItem>;

// TotalCountTimeIntervalItem
interface RbxTotalCountTimeIntervalItem extends RbxStatsItem {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "TotalCountTimeIntervalItem";
}
type TotalCountTimeIntervalItem = RbxTotalCountTimeIntervalItem & Indexable<RbxTotalCountTimeIntervalItem>;

// StopWatchReporter
interface RbxStopWatchReporter extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "StopWatchReporter";
}
type StopWatchReporter = RbxStopWatchReporter & Indexable<RbxStopWatchReporter>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "StopWatchReporter"): StopWatchReporter;
}

// Studio
interface RbxStudio extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Studio";
	["Always Save Script Changes"]: boolean;
	["Animate Hover Over"]: boolean;
	["Attach Debugger To"]: Enum.DEPRECATED_DebuggerDataModelPreference;
	["Auto Indent"]: boolean;
	["Auto-Recovery Enabled"]: boolean;
	["Auto-Recovery Interval (Minutes)"]: number;
	["Auto-Recovery Path"]: QDir;
	["Auto-Save Enabled"]: boolean;
	["Auto-Save Interval (Minutes)"]: number;
	["Auto-Save Path"]: QDir;
	["Background Color"]: Color3;
	["Basic Objects Display Mode"]: Enum.ListDisplayMode;
	["Built-in Function Color"]: Color3;
	["Camera Mouse Wheel Speed"]: number;
	["Camera Shift Speed"]: number;
	["Camera Speed"]: number;
	["Camera Zoom to Mouse Position"]: boolean;
	["Clear Output On Start"]: boolean;
	["Comment Color"]: Color3;
	DefaultScriptFileDir: QDir;
	DeprecatedObjectsShown: boolean;
	["Device Pairing Code"]: number;
	["Disable Accurate Play Solo"]: boolean;
	["Drag Multiple Parts As Single Part"]: boolean;
	["Enable Autocomplete"]: boolean;
	["Enable CoreScript Debugger"]: boolean;
	["Error Color"]: Color3;
	["Find Selection Background Color"]: Color3;
	Font: QFont;
	["Hover Animate Speed"]: Enum.HoverAnimateSpeed;
	["Hover Over Color"]: Color3;
	["Import mesh files as single mesh"]: boolean;
	["Keyword Color"]: Color3;
	["Line Thickness"]: number;
	LuaDebuggerEnabled: boolean;
	readonly LuaDebuggerEnabledAtStartup: boolean;
	["Matching Word Background Color"]: Color3;
	["Maximum Output Lines"]: number;
	["Number Color"]: Color3;
	["Only Play Audio from Window in Focus"]: boolean;
	["Operator Color"]: Color3;
	["Output Font"]: QFont;
	["Output Layout Mode"]: Enum.OutputLayoutMode;
	OverrideCoreScripts: boolean;
	OverrideCoreScriptsDir: QDir;
	PermissionLevelShown: Enum.PermissionLevelShown;
	PluginsDir: QDir;
	["Preprocessor Color"]: Color3;
	RecentSavesDir: QDir;
	["Render Throttle Percentage"]: number;
	["Respect Studio shortcuts when game has focus"]: boolean;
	RuntimeUndoBehavior: Enum.RuntimeUndoBehavior;
	ScriptTimeoutLength: number;
	["Select Color"]: Color3;
	["Select/Hover Color"]: Color3;
	["Selection Background Color"]: Color3;
	["Selection Color"]: Color3;
	["Server Audio Behavior"]: Enum.ServerAudioBehavior;
	["Show Core GUI in Explorer while Playing"]: boolean;
	["Show Diagnostics Bar"]: boolean;
	["Show Hidden Objects in Explorer"]: boolean;
	["Show Hover Over"]: boolean;
	["Show Navigation Mesh"]: boolean;
	["Show Plugin GUI Service in Explorer"]: boolean;
	["Show QT warnings in output"]: boolean;
	["Show plus button on hover in Explorer"]: boolean;
	["String Color"]: Color3;
	["Tab Width"]: number;
	["Text Color"]: Color3;
	["Text Wrapping"]: boolean;
	Theme?: Instance;
	readonly ["UI Theme"]: Enum.UITheme;
	["Warning Color"]: Color3;
}
type Studio = RbxStudio & Indexable<RbxStudio>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "Studio"): Studio;
}

// StudioService
interface RbxStudioService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "StudioService";
	readonly ActiveScript?: Instance;
}
type StudioService = RbxStudioService & Indexable<RbxStudioService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "StudioService"): StudioService;
}

// StudioTheme
interface RbxStudioTheme extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "StudioTheme";
}
type StudioTheme = RbxStudioTheme & Indexable<RbxStudioTheme>;

// TaskScheduler
interface RbxTaskScheduler extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "TaskScheduler";
	readonly SchedulerDutyCycle: number;
	readonly SchedulerRate: number;
	ThreadPoolConfig: Enum.ThreadPoolConfig;
	readonly ThreadPoolSize: number;
}
type TaskScheduler = RbxTaskScheduler & Indexable<RbxTaskScheduler>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "TaskScheduler"): TaskScheduler;
}

// Team
interface RbxTeam extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Team";
	AutoAssignable: boolean;
	TeamColor: BrickColor;
}
type Team = RbxTeam & Indexable<RbxTeam>;

// Teams
interface RbxTeams extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Teams";
}
type Teams = RbxTeams & Indexable<RbxTeams>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "Teams"): Teams;
}

// TeleportService
interface RbxTeleportService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "TeleportService";
	GetArrivingTeleportGui(): Instance | undefined;
	GetLocalPlayerTeleportData(): unknown;
	GetTeleportSetting(setting: string): unknown;
	SetTeleportGui(gui: Instance): void;
	SetTeleportSetting(setting: string, value?: any): void;
	TeleportToPlaceInstance(placeId: number, instanceId: string, player?: Instance, spawnName?: string, teleportData?: any, customLoadingScreen?: Instance): void;
	TeleportToSpawnByName(placeId: number, spawnName: string, player?: Instance, teleportData?: any, customLoadingScreen?: Instance): void;
	readonly LocalPlayerArrivedFromTeleport: RBXScriptSignal<(loadingGui: Instance, dataTable?: any) => void>;
}
type TeleportService = RbxTeleportService & Indexable<RbxTeleportService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "TeleportService"): TeleportService;
}

// TerrainRegion
interface RbxTerrainRegion extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "TerrainRegion";
	readonly SizeInCells: Vector3;
}
type TerrainRegion = RbxTerrainRegion & Indexable<RbxTerrainRegion>;

// TestService
interface RbxTestService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "TestService";
	AutoRuns: boolean;
	Description: string;
	readonly ErrorCount: number;
	ExecuteWithStudioRun: boolean;
	Is30FpsThrottleEnabled: boolean;
	IsPhysicsEnvironmentalThrottled: boolean;
	IsSleepAllowed: boolean;
	NumberOfPlayers: number;
	SimulateSecondsLag: number;
	readonly TestCount: number;
	Timeout: number;
	readonly WarnCount: number;
	Check(condition: boolean, description: string, source?: Instance, line?: number): void;
	Checkpoint(text: string, source?: Instance, line?: number): void;
	Done(): void;
	Error(description: string, source?: Instance, line?: number): void;
	Fail(description: string, source?: Instance, line?: number): void;
	Message(text: string, source?: Instance, line?: number): void;
	Require(condition: boolean, description: string, source?: Instance, line?: number): void;
	Warn(condition: boolean, description: string, source?: Instance, line?: number): void;
	isFeatureEnabled(name: string): boolean;
	readonly ServerCollectConditionalResult: RBXScriptSignal<(condition: boolean, text: string, script: Instance, line: number) => void>;
	readonly ServerCollectResult: RBXScriptSignal<(text: string, script: Instance, line: number) => void>;
}
type TestService = RbxTestService & Indexable<RbxTestService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "TestService"): TestService;
}

// TextFilterResult
interface RbxTextFilterResult extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "TextFilterResult";
	GetChatForUserAsync(toUserId: number): string;
	GetNonChatStringForBroadcastAsync(): string;
	GetNonChatStringForUserAsync(toUserId: number): string;
}
type TextFilterResult = RbxTextFilterResult & Indexable<RbxTextFilterResult>;

// TextService
interface RbxTextService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "TextService";
	GetTextSize(string: string, fontSize: number, font: Enum.Font, frameSize: Vector2): Vector2;
	FilterStringAsync(stringToFilter: string, fromUserId: number, textContext?: Enum.TextFilterContext): Instance | undefined;
}
type TextService = RbxTextService & Indexable<RbxTextService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "TextService"): TextService;
}

// ThirdPartyUserService
interface RbxThirdPartyUserService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ThirdPartyUserService";
}
type ThirdPartyUserService = RbxThirdPartyUserService & Indexable<RbxThirdPartyUserService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "ThirdPartyUserService"): ThirdPartyUserService;
}

// TimerService
interface RbxTimerService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "TimerService";
}
type TimerService = RbxTimerService & Indexable<RbxTimerService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "TimerService"): TimerService;
}

// TouchInputService
interface RbxTouchInputService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "TouchInputService";
}
type TouchInputService = RbxTouchInputService & Indexable<RbxTouchInputService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "TouchInputService"): TouchInputService;
}

// TouchTransmitter
interface RbxTouchTransmitter extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "TouchTransmitter";
}
type TouchTransmitter = RbxTouchTransmitter & Indexable<RbxTouchTransmitter>;

// Trail
interface RbxTrail extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Trail";
	Attachment0?: Attachment;
	Attachment1?: Attachment;
	Color: ColorSequence;
	Enabled: boolean;
	FaceCamera: boolean;
	Lifetime: number;
	LightEmission: number;
	LightInfluence: number;
	MaxLength: number;
	MinLength: number;
	Texture: string;
	TextureLength: number;
	TextureMode: Enum.TextureMode;
	Transparency: NumberSequence;
	WidthScale: NumberSequence;
	Clear(): void;
}
type Trail = RbxTrail & Indexable<RbxTrail>;

// Translator
interface RbxTranslator extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Translator";
	readonly LocaleId: string;
	FormatByKey(key: string, args?: any): string;
	Translate(context: Instance, text: string): string;
}
type Translator = RbxTranslator & Indexable<RbxTranslator>;

// TweenBase
interface RbxTweenBase extends RbxInstance {
	/** The current state of how the tween is animating. Possible values are Begin, Playing, Paused, Completed and Cancelled. This property is modified by using functions such as Tween:Play(), Tween:Pause(), and Tween:Cancel(). Read-only. */
	readonly PlaybackState: Enum.PlaybackState;
	/** Stops the tween animation. Animation can be restarted by calling Play(). Animation will start from the beginning values. */
	Cancel(): void;
	/** Temporarily stops the tween animation. Animation can be resumed by calling Play(). */
	Pause(): void;
	/** Starts or resumes (if Tween.PlaybackState is Paused) the tween animation. If current PlaybackState is Cancelled, this property will reset the tween to the beginning properties and play the animations from the beginning. */
	Play(): void;
	/** Fires when the tween either reaches PlaybackState Completed or Cancelled. PlaybackState of one of these types is passed as the first arg to the function listening to this event. */
	readonly Completed: RBXScriptSignal<(playbackState: Enum.PlaybackState) => void>;
}
type TweenBase = Tween;

// Tween
interface RbxTween extends RbxTweenBase {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Tween";
	readonly Instance?: Instance;
	readonly TweenInfo: TweenInfo;
}
type Tween = RbxTween & Indexable<RbxTween>;

// TweenService
interface RbxTweenService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "TweenService";
}
type TweenService = RbxTweenService & Indexable<RbxTweenService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "TweenService"): TweenService;
}

// UIBase
interface RbxUIBase extends RbxInstance {
}
type UIBase = UIComponent;

// UIComponent
interface RbxUIComponent extends RbxUIBase {
}
type UIComponent = UIConstraint | UILayout | UIPadding | UIScale;

// UIConstraint
interface RbxUIConstraint extends RbxUIComponent {
}
type UIConstraint = UIAspectRatioConstraint | UISizeConstraint | UITextSizeConstraint;

// UIAspectRatioConstraint
interface RbxUIAspectRatioConstraint extends RbxUIConstraint {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "UIAspectRatioConstraint";
	/** The aspect ratio to maintain. This is the width/height. Only positive numbers allowed. */
	AspectRatio: number;
	/** Describes how the aspect ratio will determine its size. Options are FitWithinMaxSize, ScaleWithParentSize. FitWithinMaxSize will make the element the maximum size it can be within the current possible AbsoluteSize of the element while maintaining the AspectRatio. ScaleWithParentSize will make the element the closest to the parent elements maximum size while maintaining aspect ratio. */
	AspectType: Enum.AspectType;
	/** Describes which axis to use when determining the new size of the element, while keeping respect to the aspect ratio. */
	DominantAxis: Enum.DominantAxis;
}
type UIAspectRatioConstraint = RbxUIAspectRatioConstraint & Indexable<RbxUIAspectRatioConstraint>;

// UISizeConstraint
interface RbxUISizeConstraint extends RbxUIConstraint {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "UISizeConstraint";
	/** The biggest size the GuiObject is allowed to be. */
	MaxSize: Vector2;
	/** The smallest size the GuiObject is allowed to be. */
	MinSize: Vector2;
}
type UISizeConstraint = RbxUISizeConstraint & Indexable<RbxUISizeConstraint>;

// UITextSizeConstraint
interface RbxUITextSizeConstraint extends RbxUIConstraint {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "UITextSizeConstraint";
	/** The biggest size the font is allowed to be. */
	MaxTextSize: number;
	/** The smallest size the font is allowed to be. */
	MinTextSize: number;
}
type UITextSizeConstraint = RbxUITextSizeConstraint & Indexable<RbxUITextSizeConstraint>;

// UILayout
interface RbxUILayout extends RbxUIComponent {
}
type UILayout = UIGridStyleLayout;

// UIGridStyleLayout
interface RbxUIGridStyleLayout extends RbxUILayout {
	readonly AbsoluteContentSize: Vector2;
	/** Determines which direction to fill the grid. Can be Horizontal or Vertical. */
	FillDirection: Enum.FillDirection;
	/** Determines how grid is placed within it's parent's container in the x direction. Can be Left, Center, or Right. */
	HorizontalAlignment: Enum.HorizontalAlignment;
	/** Determines how we decide which element to place next. Can be Name or Custom. If using Custom, make sure SetCustomSortFunction was called with an appropriate sort function. */
	SortOrder: Enum.SortOrder;
	/** Determines how grid is placed within it's parent's container in the y direction. Can be Top, Center, or Bottom. */
	VerticalAlignment: Enum.VerticalAlignment;
	/** Forces a relayout of all elements. Useful when sort is set to Custom. */
	ApplyLayout(): void;
}
type UIGridStyleLayout = UIGridLayout | UIListLayout | UIPageLayout | UITableLayout;

// UIGridLayout
interface RbxUIGridLayout extends RbxUIGridStyleLayout {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "UIGridLayout";
	/** How much space between elements there should be. */
	CellPadding: UDim2;
	/** Denotes what size each element should be. Can be overridden by elements using constraints on individual elements. */
	CellSize: UDim2;
	/** Determines how many cells over in the FillDirection we go before starting a new row or column. Set to 0 for max cell count.  Will be clamped if this is set higher than the parent container allows room for. */
	FillDirectionMaxCells: number;
	/** Which corner we start laying the elements out from. Can be TopLeft, TopRight, BottomLeft, BottomRight. */
	StartCorner: Enum.StartCorner;
}
type UIGridLayout = RbxUIGridLayout & Indexable<RbxUIGridLayout>;

// UIListLayout
interface RbxUIListLayout extends RbxUIGridStyleLayout {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "UIListLayout";
	/** Determines the amount of free space between each element. Can be set either using scale (Percentage of parent's size in the current direction) or offset (a static spacing value, similar to pixel size). */
	Padding: UDim;
}
type UIListLayout = RbxUIListLayout & Indexable<RbxUIListLayout>;

// UIPageLayout
interface RbxUIPageLayout extends RbxUIGridStyleLayout {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "UIPageLayout";
	/** Whether or not to animate transitions between pages. */
	Animated: boolean;
	/** Whether or not the page layout wraps around at the ends. */
	Circular: boolean;
	/** The page that is either currently being displayed or is the target of the current animation. */
	readonly CurrentPage?: GuiObject;
	/** The easing direction to use when performing an animation. */
	EasingDirection: Enum.EasingDirection;
	/** The easing style to use when performing an animation. */
	EasingStyle: Enum.EasingStyle;
	GamepadInputEnabled: boolean;
	/** Determines the amount that pages are separated from each other by. Can be set either using scale (Percentage of parent's size in the current direction) or offset (a static spacing value, similar to pixel size). */
	Padding: UDim;
	ScrollWheelInputEnabled: boolean;
	TouchInputEnabled: boolean;
	/** The length of the animation. */
	TweenTime: number;
	/** If the instance is in the layout, then it sets CurrentPage to it and animtes to it. If circular layout is set, it will take the shortest path. */
	JumpTo(page: Instance): void;
	/** If the index is >= 0 and less than the size of the layout, acts like JumpTo. If it's out of bounds and circular is set, it will animate the full distance between the in-bounds index of CurrentPage and the new index. */
	JumpToIndex(index: number): void;
	/** Sets CurrentPage to the page after the current page and animates to it, or does nothing if there isn't a next page. */
	Next(): void;
	/** Sets CurrentPage to the page after the current page and animates to it, or does nothing if there isn't a next page. */
	Previous(): void;
	/** Fires when a page comes into view, and is going to be rendered. */
	readonly PageEnter: RBXScriptSignal<(page: Instance) => void>;
	/** Fires when a page leaves view, and will not be rendered. */
	readonly PageLeave: RBXScriptSignal<(page: Instance) => void>;
	/** Fires when an animation to CurrentPage is completed without being cancelled, and the view stops scrolling. */
	readonly Stopped: RBXScriptSignal<(currentPage: Instance) => void>;
}
type UIPageLayout = RbxUIPageLayout & Indexable<RbxUIPageLayout>;

// UITableLayout
interface RbxUITableLayout extends RbxUIGridStyleLayout {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "UITableLayout";
	/** Whether the table should expand to fill the available space of its container, column-wise. */
	FillEmptySpaceColumns: boolean;
	/** Whether the table should expand to fill the available space of its container, row-wise. */
	FillEmptySpaceRows: boolean;
	/** Whether the direct siblings are considered the rows or the columns. The children of the direct siblings are the columns or rows, respectively. */
	MajorAxis: Enum.TableMajorAxis;
	/** The amount of padding to insert in between the cells of the table. */
	Padding: UDim2;
}
type UITableLayout = RbxUITableLayout & Indexable<RbxUITableLayout>;

// UIPadding
interface RbxUIPadding extends RbxUIComponent {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "UIPadding";
	/** The padding to apply on the bottom side relative to the parent's normal size. */
	PaddingBottom: UDim;
	/** The padding to apply on the left side relative to the parent's normal size. */
	PaddingLeft: UDim;
	/** The padding to apply on the right side relative to the parent's normal size. */
	PaddingRight: UDim;
	/** The padding to apply on the top side relative to the parent's normal size. */
	PaddingTop: UDim;
}
type UIPadding = RbxUIPadding & Indexable<RbxUIPadding>;

// UIScale
interface RbxUIScale extends RbxUIComponent {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "UIScale";
	/** The scale factor to apply. */
	Scale: number;
}
type UIScale = RbxUIScale & Indexable<RbxUIScale>;

// UserGameSettings
interface RbxUserGameSettings extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "UserGameSettings";
	ComputerCameraMovementMode: Enum.ComputerCameraMovementMode;
	ComputerMovementMode: Enum.ComputerMovementMode;
	ControlMode: Enum.ControlMode;
	GamepadCameraSensitivity: number;
	MasterVolume: number;
	MouseSensitivity: number;
	RCCProfilerRecordFrameRate: number;
	RCCProfilerRecordTimeFrame: number;
	RotationType: Enum.RotationType;
	SavedQualityLevel: Enum.SavedQualitySetting;
	TouchCameraMovementMode: Enum.TouchCameraMovementMode;
	TouchMovementMode: Enum.TouchMovementMode;
	GetCameraYInvertValue(): number;
	GetOnboardingCompleted(onboardingId: string): boolean;
	InFullScreen(): boolean;
	InStudioMode(): boolean;
	SetCameraYInvertVisible(): void;
	SetGamepadCameraSensitivityVisible(): void;
	SetOnboardingCompleted(onboardingId: string): void;
	readonly FullscreenChanged: RBXScriptSignal<(isFullscreen: boolean) => void>;
	readonly StudioModeChanged: RBXScriptSignal<(isStudioMode: boolean) => void>;
}
type UserGameSettings = RbxUserGameSettings & Indexable<RbxUserGameSettings>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "UserGameSettings"): UserGameSettings;
}

// UserInputService
interface RbxUserInputService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "UserInputService";
	/** Returns true if the local device has an accelerometer, false otherwise. */
	readonly AccelerometerEnabled: boolean;
	readonly GamepadEnabled: boolean;
	/** Returns true if the local device has an gyroscope, false otherwise. */
	readonly GyroscopeEnabled: boolean;
	/** Returns true if the local device accepts keyboard input, false otherwise. */
	readonly KeyboardEnabled: boolean;
	ModalEnabled: boolean;
	MouseBehavior: Enum.MouseBehavior;
	MouseDeltaSensitivity: number;
	/** Returns true if the local device accepts mouse input, false otherwise. */
	readonly MouseEnabled: boolean;
	MouseIconEnabled: boolean;
	readonly OnScreenKeyboardPosition: Vector2;
	readonly OnScreenKeyboardSize: Vector2;
	readonly OnScreenKeyboardVisible: boolean;
	/** Returns true if the local device accepts touch input, false otherwise. */
	readonly TouchEnabled: boolean;
	readonly VREnabled: boolean;
	GamepadSupports(gamepadNum: Enum.UserInputType, gamepadKeyCode: Enum.KeyCode): boolean;
	/** Returns an InputObject that describes the device's current acceleration. This is fired with an InputObject, which has type Enum.InputType.Accelerometer, and position that shows the g force in each local device axis.  The delta property describes the amount of rotation that last happened. This event only fires locally. */
	GetDeviceAcceleration(): Instance | undefined;
	/** Returns an InputObject that describes the device's current gravity vector. This is fired with an InputObject, which has type Enum.InputType.Accelerometer, and position that shows the g force in each local device axis. The delta property describes the amount of rotation that last happened. This event only fires locally. */
	GetDeviceGravity(): Instance | undefined;
	GetFocusedTextBox(): Instance | undefined;
	GetGamepadConnected(gamepadNum: Enum.UserInputType): boolean;
	GetLastInputType(): Enum.UserInputType;
	GetMouseDelta(): Vector2;
	GetMouseLocation(): Vector2;
	GetUserCFrame(type: Enum.UserCFrame): CFrame;
	IsGamepadButtonDown(gamepadNum: Enum.UserInputType, gamepadKeyCode: Enum.KeyCode): boolean;
	IsKeyDown(keyCode: Enum.KeyCode): boolean;
	IsMouseButtonPressed(mouseButton: Enum.UserInputType): boolean;
	IsNavigationGamepad(gamepadEnum: Enum.UserInputType): boolean;
	RecenterUserHeadCFrame(): void;
	SetNavigationGamepad(gamepadEnum: Enum.UserInputType, enabled: boolean): void;
	/** Fired when a user moves a device that has an accelerometer. This is fired with an InputObject, which has type Enum.InputType.Accelerometer, and position that shows the g force in each local device axis. This event only fires locally. */
	readonly DeviceAccelerationChanged: RBXScriptSignal<(acceleration: Instance) => void>;
	/** Fired when the force of gravity changes on a device that has an accelerometer. This is fired with an InputObject, which has type Enum.InputType.Accelerometer, and position that shows the g force in each local device axis. This event only fires locally. */
	readonly DeviceGravityChanged: RBXScriptSignal<(gravity: Instance) => void>;
	/** Fired when a user rotates a device that has an gyroscope. This is fired with an InputObject, which has type Enum.InputType.Gyroscope, and position that shows total rotation in each local device axis.  The delta property describes the amount of rotation that last happened. A second argument of Vector4 is the device's current quaternion rotation in reference to it's default reference frame. This event only fires locally. */
	readonly DeviceRotationChanged: RBXScriptSignal<(rotation: Instance, cframe: CFrame) => void>;
	readonly GamepadConnected: RBXScriptSignal<(gamepadNum: Enum.UserInputType) => void>;
	readonly GamepadDisconnected: RBXScriptSignal<(gamepadNum: Enum.UserInputType) => void>;
	readonly JumpRequest: RBXScriptSignal<() => void>;
	readonly LastInputTypeChanged: RBXScriptSignal<(lastInputType: Enum.UserInputType) => void>;
	/** Fired when a user stops text entry into a textbox (usually by pressing return or clicking/tapping somewhere else on the screen). Argument is the textbox that was taken out of focus. This event only fires locally. */
	readonly TextBoxFocusReleased: RBXScriptSignal<(textboxReleased: Instance) => void>;
	/** Fired when a user clicks/taps on a textbox to begin text entry. Argument is the textbox that was put in focus. This also fires if a textbox forces focus on the user. This event only fires locally. */
	readonly TextBoxFocused: RBXScriptSignal<(textboxFocused: Instance) => void>;
	/** Fired when a user moves their finger on a TouchEnabled device. 'touch' is an InputObject, which contains useful data for querying user input.  This event only fires locally.  This event will always fire regardless of game state. */
	readonly TouchEnded: RBXScriptSignal<(touch: Instance, gameProcessedEvent: boolean) => void>;
	/** Fired when a user holds at least one finger for a short amount of time on the same screen position on a TouchEnabled device. 'touchPositions' is a Lua array of Vector2, each indicating the position of all the fingers involved in the gesture. 'state' indicates the Enum.UserInputState of the gesture.  This event only fires locally.  This event will always fire regardless of game state. */
	readonly TouchLongPress: RBXScriptSignal<(touchPositions: Array<any>, state: Enum.UserInputState, gameProcessedEvent: boolean) => void>;
	/** Fired when a user moves their finger on a TouchEnabled device. 'touch' is an InputObject, which contains useful data for querying user input.  This event only fires locally.  This event will always fire regardless of game state. */
	readonly TouchMoved: RBXScriptSignal<(touch: Instance, gameProcessedEvent: boolean) => void>;
	/** Fired when a user drags at least one finger on a TouchEnabled device. 'touchPositions' is a Lua array of Vector2, each indicating the position of all the fingers involved in the gesture. 'totalTranslation' is a Vector2, indicating how far the pan gesture has gone from its starting point. 'velocity' is a Vector2 that indicates how quickly the gesture is being performed in each dimension. 'state' indicates the Enum.UserInputState of the gesture.  This event only fires locally.  This event will always fire regardless of game state. */
	readonly TouchPan: RBXScriptSignal<(touchPositions: Array<any>, totalTranslation: Vector2, velocity: Vector2, state: Enum.UserInputState, gameProcessedEvent: boolean) => void>;
	/** Fired when a user pinches their fingers on a TouchEnabled device. 'touchPositions' is a Lua array of Vector2, each indicating the position of all the fingers involved in the pinch gesture. 'scale' is a float that indicates the difference from the beginning of the pinch gesture. 'velocity' is a float indicating how quickly the pinch gesture is happening. 'state' indicates the Enum.UserInputState of the gesture.  This event only fires locally.  This event will always fire regardless of game state. */
	readonly TouchPinch: RBXScriptSignal<(touchPositions: Array<any>, scale: number, velocity: number, state: Enum.UserInputState, gameProcessedEvent: boolean) => void>;
	/** Fired when a user rotates two fingers on a TouchEnabled device. 'touchPositions' is a Lua array of Vector2, each indicating the position of all the fingers involved in the gesture. 'rotation' is a float indicating how much the rotation has gone from the start of the gesture. 'velocity' is a float that indicates how quickly the gesture is being performed. 'state' indicates the Enum.UserInputState of the gesture.  This event only fires locally.  This event will always fire regardless of game state. */
	readonly TouchRotate: RBXScriptSignal<(touchPositions: Array<any>, rotation: number, velocity: number, state: Enum.UserInputState, gameProcessedEvent: boolean) => void>;
	/** Fired when a user places their finger on a TouchEnabled device. 'touch' is an InputObject, which contains useful data for querying user input.  This event only fires locally.  This event will always fire regardless of game state. */
	readonly TouchStarted: RBXScriptSignal<(touch: Instance, gameProcessedEvent: boolean) => void>;
	/** Fired when a user swipes their fingers on a TouchEnabled device. 'swipeDirection' is an Enum.SwipeDirection, indicating the direction the user swiped. 'numberOfTouches' is an int that indicates how many touches were involved with the gesture.  This event only fires locally.  This event will always fire regardless of game state. */
	readonly TouchSwipe: RBXScriptSignal<(swipeDirection: Enum.SwipeDirection, numberOfTouches: number, gameProcessedEvent: boolean) => void>;
	/** Fired when a user taps their finger on a TouchEnabled device. 'touchPositions' is a Lua array of Vector2, each indicating the position of all the fingers involved in the tap gesture. This event only fires locally.  This event will always fire regardless of game state. */
	readonly TouchTap: RBXScriptSignal<(touchPositions: Array<any>, gameProcessedEvent: boolean) => void>;
	readonly TouchTapInWorld: RBXScriptSignal<(position: Vector2, processedByUI: boolean) => void>;
	readonly UserCFrameChanged: RBXScriptSignal<(type: Enum.UserCFrame, value: CFrame) => void>;
	readonly WindowFocusReleased: RBXScriptSignal<() => void>;
	readonly WindowFocused: RBXScriptSignal<() => void>;
}
type UserInputService = RbxUserInputService & Indexable<RbxUserInputService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "UserInputService"): UserInputService;
}

// VRService
interface RbxVRService extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "VRService";
	GuiInputUserCFrame: Enum.UserCFrame;
	readonly VREnabled: boolean;
	GetTouchpadMode(pad: Enum.VRTouchpad): Enum.VRTouchpadMode;
	GetUserCFrame(type: Enum.UserCFrame): CFrame;
	GetUserCFrameEnabled(type: Enum.UserCFrame): boolean;
	RecenterUserHeadCFrame(): void;
	RequestNavigation(cframe: CFrame, inputUserCFrame: Enum.UserCFrame): void;
	SetTouchpadMode(pad: Enum.VRTouchpad, mode: Enum.VRTouchpadMode): void;
	readonly NavigationRequested: RBXScriptSignal<(cframe: CFrame, inputUserCFrame: Enum.UserCFrame) => void>;
	readonly TouchpadModeChanged: RBXScriptSignal<(pad: Enum.VRTouchpad, mode: Enum.VRTouchpadMode) => void>;
	readonly UserCFrameChanged: RBXScriptSignal<(type: Enum.UserCFrame, value: CFrame) => void>;
	readonly UserCFrameEnabled: RBXScriptSignal<(type: Enum.UserCFrame, enabled: boolean) => void>;
}
type VRService = RbxVRService & Indexable<RbxVRService>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "VRService"): VRService;
}

// ValueBase
interface RbxValueBase extends RbxInstance {
}
type ValueBase = BinaryStringValue | BoolValue | BrickColorValue | CFrameValue | Color3Value | DoubleConstrainedValue | IntConstrainedValue | IntValue | NumberValue | ObjectValue | RayValue | StringValue | Vector3Value;

// BinaryStringValue
interface RbxBinaryStringValue extends RbxValueBase {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "BinaryStringValue";
}
type BinaryStringValue = RbxBinaryStringValue & Indexable<RbxBinaryStringValue>;

// BoolValue
interface RbxBoolValue extends RbxValueBase {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "BoolValue";
	Value: boolean;
}
type BoolValue = RbxBoolValue & Indexable<RbxBoolValue>;

// BrickColorValue
interface RbxBrickColorValue extends RbxValueBase {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "BrickColorValue";
	Value: BrickColor;
}
type BrickColorValue = RbxBrickColorValue & Indexable<RbxBrickColorValue>;

// CFrameValue
interface RbxCFrameValue extends RbxValueBase {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "CFrameValue";
	Value: CFrame;
}
type CFrameValue = RbxCFrameValue & Indexable<RbxCFrameValue>;

// Color3Value
interface RbxColor3Value extends RbxValueBase {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Color3Value";
	Value: Color3;
}
type Color3Value = RbxColor3Value & Indexable<RbxColor3Value>;

// DoubleConstrainedValue
interface RbxDoubleConstrainedValue extends RbxValueBase {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "DoubleConstrainedValue";
	ConstrainedValue: number;
	/** The maximum we allow this Value to be set.  If Value is set higher than this, it automatically gets adjusted to MaxValue */
	MaxValue: number;
	/** The minimum we allow this Value to be set.  If Value is set lower than this, it automatically gets adjusted to MinValue */
	MinValue: number;
	Value: number;
}
type DoubleConstrainedValue = RbxDoubleConstrainedValue & Indexable<RbxDoubleConstrainedValue>;

// IntConstrainedValue
interface RbxIntConstrainedValue extends RbxValueBase {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "IntConstrainedValue";
	ConstrainedValue: number;
	MaxValue: number;
	MinValue: number;
	Value: number;
}
type IntConstrainedValue = RbxIntConstrainedValue & Indexable<RbxIntConstrainedValue>;

// IntValue
interface RbxIntValue extends RbxValueBase {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "IntValue";
	Value: number;
}
type IntValue = RbxIntValue & Indexable<RbxIntValue>;

// NumberValue
interface RbxNumberValue extends RbxValueBase {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "NumberValue";
	Value: number;
}
type NumberValue = RbxNumberValue & Indexable<RbxNumberValue>;

// ObjectValue
interface RbxObjectValue extends RbxValueBase {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ObjectValue";
	Value?: Instance;
}
type ObjectValue = RbxObjectValue & Indexable<RbxObjectValue>;

// RayValue
interface RbxRayValue extends RbxValueBase {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "RayValue";
	Value: Ray;
}
type RayValue = RbxRayValue & Indexable<RbxRayValue>;

// StringValue
interface RbxStringValue extends RbxValueBase {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "StringValue";
	Value: string;
}
type StringValue = RbxStringValue & Indexable<RbxStringValue>;

// Vector3Value
interface RbxVector3Value extends RbxValueBase {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Vector3Value";
	Value: Vector3;
}
type Vector3Value = RbxVector3Value & Indexable<RbxVector3Value>;

// VirtualInputManager
interface RbxVirtualInputManager extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "VirtualInputManager";
}
type VirtualInputManager = RbxVirtualInputManager & Indexable<RbxVirtualInputManager>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "VirtualInputManager"): VirtualInputManager;
}

// VirtualUser
interface RbxVirtualUser extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "VirtualUser";
}
type VirtualUser = RbxVirtualUser & Indexable<RbxVirtualUser>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "VirtualUser"): VirtualUser;
}

// Visit
interface RbxVisit extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Visit";
}
type Visit = RbxVisit & Indexable<RbxVisit>;
interface RbxServiceProvider extends RbxInstance {
	GetService(className: "Visit"): Visit;
}

// WeldConstraint
interface RbxWeldConstraint extends RbxInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "WeldConstraint";
	/** Read-only boolean, true if the joint is active in world. Rigid joints may be inactive if they are redundant or form cycles. */
	readonly Active: boolean;
	Enabled: boolean;
	Part0?: BasePart;
	Part1?: BasePart;
}
type WeldConstraint = RbxWeldConstraint & Indexable<RbxWeldConstraint>;

